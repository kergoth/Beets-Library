directory: Library
library: Library/library.db
statefile: Library/state.pickle
pluginpath:
  - ./plugins
  - ./plugins/beets-kergoth/beetsplug
  - ./plugins/whatlastgenre/plugin/beets/beetsplug

per_disc_numbering: true
id3v23: true
format_album: '%ifdef{id,[$id] }$albumartist - $album%if{$albumtypes,%if{$atypes, $atypes}}%aunique{}%ifdef{albumadvisory,%if{$e_albumadvisory, (Explicit)}}'
format_item: '%ifdef{id,[$id] }%if{$album,$album%if{$albumtypes,%if{$atypes, $atypes}}%aunique{}%ifdef{albumadvisory,%if{$e_albumadvisory, (Explicit)}} - $disc_and_track_pre}$artist - $full_title'

sort_album: albumartist+ album+
sort_item: albumartist+ album+ disc+ track+ artist+

paths:
  default: '$source/$if_albumartist_credit/%if{$album,$album%aunique{},[non-album tracks]}/$path_filename'
  singleton: '$source/$artist/[non-album tracks]/$path_filename'
  comp: '$source/Compilations/%if{$album,$album%aunique{},[non-album tracks]}/$path_filename'
  ext:log: $albumpath/$album
  ext:cue: $albumpath/$album

# For unicode lookalikes, see:
# http://www.unicode.org/Public/security/latest/confusables.txt
replace:
  # Avoid trailing periods, invalid on Windows
  ' E\.P\.': ' EP'
  ' *(\.\.\.)$': '…'
  '\.+$': ''

  # Zero-width space
  '​': ''

  # Colon in paths is often unsupported. Use a unicode lookalike.
  ' *:': '∶'

  # Remaining default configuration for portability
  '[\\/]': _
  '^\.+': _
  '[\x00-\x1f]': _
  # '[<>"\?\*\|]': _
  '\s+$': ''
  '^\s+': ''
  '^-': _

path_sep_replace: ／

import:
  log: Library/import.log
  timid: true
  incremental: true
  default_action: skip

# Files matching these patterns are deleted from source after import
clutter:
  - '*.m3u'
  # Default:
  - Thumbs.DB
  - .DS_Store

match:
  preferred:
    countries: ['US', 'XW', 'GB|UK']
    media: ['Digital Media|File', 'CD']
  strong_rec_thresh: 0.075
  medium_rec_thresh: 0.125
  max_rec:
    unmatched_tracks: low
    missing_tracks: strong
  # The higher the weight, the lower the items go in the candidate list (greater
  # distance) when this penalty is applied.
  distance_weights:
    # Default: 3.0
    album: 6.0
    # Default: 3.0
    artist: 7.0
    # Default: 2.0
    totaltracks: 4.0
    # Default: 0.9
    missing_tracks: 1.0
    # Default: 0.6
    unmatched_tracks: 10.0
  ignored_media:
    ['DVD', 'DVD-Video', 'Blu-ray', 'HD-DVD', 'VCD', 'SVCD', 'UMD', 'VHS']

plugins:
  # Stock plugins
  - acousticbrainz
  - albumtypes
  - badfiles
  - bareasc
  - bucket
  - convert
  - chroma
  - discogs
  - duplicates
  - edit
  - embedart
  - export
  - fetchart
  - fromfilename
  - fuzzy
  - hook
  - info
  - inline
  - lyrics
  - mbsync
  - missing
  - playlist
  - random
  - smartplaylist
  - spotify
  - the
  - types
  - unimported
  - zero

  # 3rd party plugins
  - alternatives
  - bandcamp
  - copyartifacts
  - join_albums
  - wlg

  # My plugins
  # Define beet command aliases, much like you can with git
  - alias
  # Write playlists to the alternatives
  - alternativesplaylist
  # Set 'advisory' and 'albumadvisory' fields on import based on 'itunesadvisory'
  - advisory
  # Define format strings for the default list formats, format_album and format_item.
  - defaultformats
  # Named queries and query prefixes from the Beets source. 'any:', @ prefix
  # for exact match, and ^ prefix for a None value.
  - existingqueries
  # Query whether an item has embedded art
  - hasart
  # Run external scripts on hook events
  - hookscripts
  # Inspect candidate changes when importing
  - importinspect
  # Identify albums whose tracks have inconsistent album fields
  - inconsistentalbumtracks
  # Run inline python on events
  - inlinehook
  # Keep track of the most recently imported items, useful in hooks
  - last_import
  # Modify fields in imported items
  - modifyonimport
  # Modify fields with formats/templates
  - modifytmpl
  # Expect source to be set
  - musicsource
  # - nowrite
  # % prefix for non-NULL/non-None
  - otherqueries
  # Prompt choice to launch picard when importing
  - picard
  # Allow certain set_fields to apply to skipped items on reimport
  - reimportskipfields
  # Add `replace` format function for applying specific sets of replacements
  - replaceformat
  # Define saved format strings by storing them in fields
  - savedformats
  # Define named/saved queries, and define fields using those queries
  - savedqueries
  # List tracks spotify identifies as explicit/parental advisory
  - spotifyexplicit
  # Clear fields in albums in the database, obeying the 'zero' plugin configuration.
  - zeroalbum

hookscripts:
  hookspath:
    - '../hooks'
  hooks:
    - alternatives_before_update
    - alternatives_after_update
    - album_imported
    - item_imported
  args:
    alternatives_before_update: 'alternative.name, alternative.directory'
    alternatives_after_update: 'alternative.name, alternative.directory'
    album_imported: 'str(album.id)'
    item_imported: 'str(item.id)'
    # Unused
    import: '*paths'

acousticbrainz:
  tags:
    - bpm
    - mood_acoustic
    - mood_aggressive
    - mood_electronic
    - mood_happy
    - mood_party
    - mood_relaxed
    - mood_sad

alias:
  aliases:
    # Utilities
    # $ beet get-config alias.aliases.reimport
    get-config: '!sh -c "for arg; do beet config | yq e \".$arg\" -; done" -'
    # $ beet get-config-path library
    get-config-path: '!sh -c "p=\"$(beet config | yq e \".$1\" -)\"; cd \"${BEETSDIR:-~/.config/beets}\" && abspath \"$p\"" -'

    # Latest additions
    recent-albums: ls -a -f '$added $format_album' 'added-'
    recent: ls -f '$added $format_item' 'added-'
    last-week: ls -f '$added $format_item' 'added-' 'added:-7d..'
    last-month: ls -f '$added $format_item' 'added-' 'added:-30d..'

    # Reimport unidentified items
    reimport-mb: import -L mb_albumid:@

    # Strip release-specific tags. Useful in cases where the precise release
    # is unknown, or is not in MusicBrainz yet.
    norelease: modify 'asin!' 'isrc!' 'barcode!' 'catalognumber!' 'label!' 'media!' 'releasecountry!' 'releasestatus!' 'mb_albumid!' 'mb_workid!' 'mb_trackid!' 'mb_releasetrackid!' 'mb_releasegroupid!'

    # Extract embedded art only for albums missing a cover art file
    extract-missing-art: extractart -a artpath:^

    # Clear embedded art from albums that have an artpath
    clearart-albums: clearart album_id::. ^artpath:^

    missing-art: fetchart -q

    # Mac-specific
    reveal: open -R --
    picard: 'open -A "-a MusicBrainz\ Picard" --'
    vlc: 'open -A "-a VLC" --'

    # Complete non-game/non-christmas albums with more than one track
    non-game-albums: ls -a existing:2.. missing:0 ^query:is_game ^query:is_christmas

    # Very basic dupe check for albums lacking musicbrainz data, primarily
    simple-dupe-check: 'dup -Fa -k albumartist -k album -k disctotal -k albumtotal -f "[$id] $albumartist - $album - $existing/$albumtotal via $source"'
    dup-albums: dup -aF
    dup-games: dup -f '$franchise - $game - $gamedisambig | $format_album' -F -k franchise -k game -k gamedisambig ^game:^

    music: ls \^query:is_non_music
    singletons: ls singleton:true
    complete: ls -a missing:0
    high-res: albums-for samplerate:96000..

    # Show incomplete albums, skipping any albums where I only have one track
    incomplete-albums: 'ls -a -f "[$id] $albumartist - $album $existing/$albumtotal" missing:1.. \^query:is_game one_track:0'
    incomplete-games: 'ls -a -f "[$id] $albumartist - $album $existing/$albumtotal" missing:2.. one_track:0 query:is_game'

    # Red flags
    empty-artist: ls artist:@
    empty-album: ls album:@ singleton:false
    book-not-audiobook: ls genre:book ^albumtypes:audiobook
    unknown-source: ls source:Unknown , source:@
    excess-tracks: 'ls -f "$format_item $track/$tracktotal via $source" excess_tracks:1'
    negative-missing: 'ls -a -f "$missing - $format_album" missing:..-1'

    # Potential concerns
    missing-albumtotal: 'ls -a -f "$format_album $existing_by_disc" single_track:0 albumtotal:0'
    # This is automatically corrected in my import hook
    various-not-comp: ls -a album_query:is_various_not_comp

    # Informative
    non-mb-albums: ls -a mb_albumid:@
    possible-singles: ls -a albumtotal:1 albumtypes::'^(|other)$'
    possible-not-comp: ls -a comp:1 missing:0 is_comp_same_artists:1
    # These are often not an issue, just albums which feature multiple
    # artists, but aren't compilations. Cases where the album artist is the
    # producer, cases where there are featuring artist, etc.
    multiartist-not-comp: ls -a comp:0 multiartist:1
    has-multiple-genres: ls -a -f '$album_genres $format_album' all_same_genres:0

alternativesplaylist:
  auto: True
  is_relative: true
  relative_to: playlist
  playlist_dir: _Playlists

bandcamp:
  art: true
  lyrics: true
  description: comments
  split_artist_title: true

bucket:
  bucket_alpha: ['A - D', 'E - L', 'M - R', 'S - Z']
  bucket_alpha_regex:
    'A - D': ^[0-9a-dA-D…äÄ]

copyartifacts:
  extensions: .cue .log .jpg .png .txt .pdf .doc .rtf .par2

extrafiles:
  patterns:
    cue: '*.cue'
    log: '*.log'
    art:
      - '*.jpg'
      - '*.png'
    docs:
      - '*.pdf'
      - '*.txt'
      - '*.doc'
      - '*.rtf'

edit:
  itemfields: track title artist album albumdisambig tracktotal year
  albumfields: album albumartist

embedart:
  auto: false

fetchart:
  # Default
  sources: filesystem coverart itunes amazon albumart
  # Set art_source field
  store_source: true
  # Prefer higher resolution art
  high_resolution: true

# Also ignore @eaDir from the Synology NAS
ignore:
  - '@eaDir'
  # Default ignores:
  - .*
  - '*~'
  - System Volume Information
  - lost+found

importinspect:
  ignored:
    - day
    - month
    - original_day
    - original_month
  ignored_new:
    # When inspecting candidates, it's a given that release fields will
    # be added, and a number of these are shown already by the import interface,
    # so focus on non-release fields. Changes to existing release fields will still
    # be shown, as that's useful when retagging an existing item.
    - albumstatus
    - asin
    - barcode
    - catalognumber
    - catalognum
    - country
    - data_source
    - discogs_albumid
    - isrc
    - label
    - language
    - mb_albumartistid
    - mb_albumid
    - mb_artistid
    - mb_releasegroupid
    - mb_releasetrackid
    - mb_trackid
    - mb_workid
    - media
    - releasecountry
    - releasestatus
    - script

inconsistentalbumtracks:
  ignored_fields: added genre language r128_album_gain r128_album_peak rg_album_gain rg_album_peak original_year

modifyonimport:
  modify_album:
    # Sane default for albumartist_sort
    'albumartist_sort::"^$" albumartist::"^The "': 'albumartist_sort=%the{$albumartist}'
    # Need albumtypes
    'albumtype::. albumtypes::"^$"': 'albumtypes=$albumtype'
    # Likely a single
    'albumtotal:1 albumtype::"^(|other)$"': 'albumtype=single albumtypes=$single_albumtypes'
    # 'Various Artists' albums not flagged as compilations
    'album_query:is_various_not_comp': 'comp=1'
    # Genre
    'genre:Holiday': 'genre=Christmas'
  modify_album_items:
    '':
      # Sane default for artist_sort
      'artist_sort::"^$" artist::"^The "': 'artist_sort=%the{$artist}'
      # Genre
      'genre:Holiday': 'genre=Christmas'
  modify_singleton:
    # Sane default for artist_sort
    'artist_sort::"^$" artist::"^The "': 'artist_sort=%the{$artist}'
    # Clear out the album field for imported singletons
    'album::.': 'album='
    # Genre
    'genre:Holiday': 'genre=Christmas'

musicbrainz:
  extra_tags: [year, catalognum, country, media, label]
  searchlimit: 10

playlist:
  auto: true
  relative_to: playlist
  playlist_dir: Library/Playlists

reimportskipfields:
  set_fields: reimported

wlg:
    auto: no
    force: no
    count: 4
    separator: ' / '
    whitelist: wlg

types:
  # Default values
  e_advisory: int
  e_albumadvisory: int
  e_loved: bool

  # Built-in or Plugin fields
  albumtotal: int
  bpm: int

  # Album inline and format fields
  album_id: int
  album_loved: bool
  existing: int
  is_comp_same_artists: bool
  has_explicit_track: bool
  all_same_genres: bool
  multiartist: bool
  multidisc: bool
  one_track: bool
  potential_single_track: bool
  average_bpm: int

  # Item inline and format fields
  excess_tracks: bool

  # Flexible fields
  #franchise: string
  #game: string
  #gamedisambig: string
  disliked: bool
  loved: bool
  to_listen: bool

  ## set_fields
  reimported: bool

zero:
  fields: month day original_month original_day comments
  comments: [EAC, LAME]
  update_database: true

inlinehook:
  hooks:
    - event: 'album_imported'
      handler: |
        from beets.ui import UserError, log

        log.info(f'Running sanity checks on album {album}')

        items = album.items()
        if not album.albumtotal:
          log.warning(f'No track total found for {album}')
        elif len(items) > album.albumtotal:
          log.warning(f'Excess items ({len(items)} > {album.albumtotal}) for {album}')

        for item in items:
          if not item.artist:
            log.warning(f'Artist not set for {item}')
          if item.genre.lower() == 'book' and 'audiobook' not in item.albumtypes:
            log.warning(f'Genre is `book`, but `albumtypes` does not include `audiobook` for {item}')

    - event: 'item_imported'
      handler: |
        from beets.ui import UserError, log

        log.info(f'Running sanity checks on item {item}')

        if not item.artist:
          log.warning(f'Artist not set for {item}')

album_queries:
  # This is used both in an alias command and an import hook
  is_various_not_comp: 'comp:0 albumartist:@"Various Artists"'

item_queries:
  is_music: '^query:is_non_music'
  is_complete: 'missing:0'
  is_single: 'albumtypes:single'
  is_live: 'albumtypes:live'

  type_soundtrack: 'albumtypes:soundtrack'

  is_non_music: 'genre:speech , genre:meditation , genre:dharma , genre:book , genre:spoken , genre:background , albumtypes:spokenword , albumtypes:audiobook , albumtypes:"audio drama" , albumtypes:interview'
  is_sampler: 'albumtypes:sampler , album:sampler'
  is_christmas: 'genre:Christmas'
  is_classical: 'genre:Classical'
  is_game: '^game:^ , ^franchise:^ , genre:game ^query:is_sampler'
  is_soundtrack: 'query:type_soundtrack , genre:soundtrack ^query:is_sampler'
  is_mfp: 'label:"Music for Programming"'
  is_ocremix: 'label:"OverClocked ReMix"'

  potential_single_track: 'singleton:true , single_track:true'
  sole_track_candidates: 'query:is_music \^query:is_mfp \^query:is_ocremix \^query:is_game'

  dap_classical: 'query:is_classical ^loved:true ^composer:"Christopher Tin" ^query:is_game ^query:is_sampler ^query:is_soundtrack'
  dap_game: '^game:^ , ^franchise:^ , query:type_soundtrack query:is_game'
  dap_game_extra: '^query:type_soundtrack query:is_game'
  dap_loved_single_tracks: 'playlist:Loved query:potential_single_track'
  dap_sole_tracks: 'playlist:"Sole Tracks"'
  dap_soundtrack: 'query:is_soundtrack ^query:potential_single_track'
  dap_sampler: 'query:is_sampler ^query:potential_single_track'

# It's irritating that we can't reference other inline fields to avoid this
# code duplication amongst album and item fields.
album_fields:
  album_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  # Number of existing tracks in this album
  existing: len(items)

  # Used by the missing-albumtotal alias
  existing_by_disc: |
    from itertools import groupby
    def keyfunc(i):
      return i.disc or 0
    grouped = groupby(sorted(items, key=keyfunc), keyfunc)
    by_disc = [(k, len(list(v))) for k, v in grouped]
    return ','.join(str(v[1]) for v in sorted(by_disc))

  # Not used at this time, only made available
  existing_discs: |
    discs = sorted(set(i.disc for i in items if i.disc))
    return ','.join(str(d) for d in discs)

  one_track: len(items) == 1

  multidisc: disctotal > 1
  # Let me search for albums that may be a compilation but aren't flagged
  multiartist: not bool(all(item.artist == items[0].artist for item in items))

  album_loved: loved if 'loved' in globals() else False
  album_composer: composer if 'composer' in globals() else False

  # This is flagged as a compilation, but all the track artists are the same.
  # Consider setting albumartist instead. This only works when missing:0 at
  # the moment, as I can't get to the list of *available* tracks, only the
  # existing ones.
  is_comp_same_artists: comp and all(item.artist == items[0].artist for item in items)

  has_explicit_track: any(getattr(item, 'advisory', 0) == 1 for item in items)

  needs_album_genre: |
    genres = [i.genre for i in items]
    if not genre and any(g for g in genres):
      same_genres = all(g == genres[0] for g in genres)
      if not same_genres:
        return 1
    return 0

  all_same_genres: all(item.genre == items[0].genre for item in items)

  album_all_genre: items[0].genre if all(item.genre == items[0].genre for item in items) else ''
  album_all_composer: items[0].composer if all(item.composer == items[0].composer for item in items) else ''

  album_genres: "','.join(sorted(set(filter(None, (item.genre for item in items)))))"

  # For albums with bpm tags on all their tracks, give us the mean
  average_bpm: |
    item_bpms = [getattr(i, 'bpm', 0) for i in items]
    if all(i > 0 for i in item_bpms):
      return int(sum(item_bpms) / len(items))
    else:
      return 0

  excess_tracks: bool(albumtotal and existing > albumtotal)

item_fields:
  item_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  excess_tracks: bool(tracktotal and track and track > tracktotal)

  # disc and track prefix with ' - ' sep. Returns '' if track == 0 or this is the only track.
  disc_and_track_pre: |
    if not track or (tracktotal and tracktotal == 1):
      return ''
    elif disctotal > 1:
      return u'%02i.%02i - ' % (disc, track)
    else:
      return u'%02i - ' % track

  # Avoid the leading zero
  trim_track: str(track)
  trim_disc: str(disc)

  explicit_or_clean: |
    if 'advisory' in globals():
      if advisory == 1:
        return ' (Explicit)'
      elif advisory == 2:
        return ' (Clean)'
    else:
      return ''

  definite_year: u'%04i' % original_year or original_date[:3] or year or date[:3] or 0

  # Used by modifyonimport rules
  single_albumtypes: |
    if 'albumtypes' in globals():
      types = [t.strip() for t in albumtypes.split(';')]
      for t in ['other', 'album', 'ep']:
        if t in types:
          types.remove(t)
      types.insert(0, 'single')
      return '; '.join(types)
    return 'single'

album_formats:
  # Convenience
  album_id: '$id'

  # Used in path formats
  if_albumartist_credit: '%if{$albumartist_credit,$albumartist_credit,$albumartist}'
  comp_albumartist: '%if{$comp,Compilations,$albumartist}'
  albumsdir: '%if{$missing,Incomplete }Albums'
  _albumdir: '%the{%replace{adjust_album,$album%aunique{}%ifdef{albumadvisory,%if{$e_albumadvisory, (Explicit)}}}}'
  _albumartistdir: '%the{%asciify{%replace{adjust_artist,$comp_albumartist}}}'

  # Fallbacks from item fields
  albumdir: '$_albumdir'
  albumartistdir: '$_albumartistdir'

  # Deal with undefined values for queries
  e_albumadvisory: '%ifdef{albumadvisory,$albumadvisory,0}'
  e_data_source: '%ifdef{data_source}'
  e_loved: '%ifdef{loved,$loved,false}'

item_formats:
  # Used in path formats
  artist_title: '%the{$path_artist} - $full_title'
  albumdir: '%if{$album,$_albumdir,[non-album tracks]}'
  albumartistdir: '%if{$album,$_albumartistdir,$path_artist}'
  artistdir: '%the{$path_artist}'
  path_artist: '%asciify{%replace{adjust_artist,$artist}}'
  full_title: '$title%if{$e_advisory,$explicit_or_clean}'
  comp_filename: '%if{$album,$disc_and_track_pre}%if{$comp,$path_artist - }$full_title'
  # Unasciified, credited artist
  path_filename: '%if{$album,$disc_and_track_pre}%if{$comp,%if{$artist_credit,$artist_credit,$artist} - }$full_title'

  # Deal with undefined values for queries. This lets me do ls e_advisory:0,
  # instead of having to check for advisory:@.
  e_advisory: '%ifdef{advisory,$advisory,0}'
  e_data_source: '%ifdef{data_source}'
  e_loved: '%ifdef{loved,$loved,false}'

  # Like albumdir, but uses Single Tracks rather than [non-album tracks]
  dap_albumdir: '%if{$album,$_albumdir,Single Tracks}'
  gamedir: '%the{%replace{adjust_album,$game%ifdef{gamedisambig, [$gamedisambig]}}}'
  game_albumdir: '%ifdef{game,$gamedir,$dap_albumdir}'
  franchisedir: '%the{%replace{adjust_franchise,$franchise}}'

alternatives:
  dap:
    directory: '../DAP'
    formats: link
    query: ^disliked:true ^userrating:0
    paths:
      to_listen:true: 'To Listen/%replace_path{adjust_dap,%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'

      query:is_non_music: 'Non-Music/%replace_path{adjust_dap,$genre/$albumartistdir/$dap_albumdir/$comp_filename}'
      query:is_mfp: 'Music/%bucket{$label,alpha}/%replace_path{adjust_dap,$label/$full_title}'

      'query:dap_sole_tracks query:dap_classical': '%replace_path{adjust_dap,Classical Music/Single Tracks/$artist_title}'
      query:dap_classical: 'Classical Music/%replace_path{adjust_dap,%if{$potential_single_track,$artistdir/Single Tracks/$full_title,$albumartistdir/$dap_albumdir/$comp_filename}}'

      'genre:Chiptune album_loved:true': 'Loved Chiptune Music/%replace_path{adjust_dap,%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'
      'genre:Chiptune query:is_game ^loved:true': 'Chiptune Game Music/%replace_path{adjust_dap,%ifdef{franchise,%bucket{$franchisedir,alpha}/$franchisedir/,%bucket{$game_albumdir,alpha}/}$game_albumdir/$comp_filename}'
      'genre:Chiptune ^loved:true': 'Chiptune Music/%replace_path{adjust_dap,%if{$potential_single_track,$artistdir/Single Tracks/$full_title,$albumartistdir/$dap_albumdir/$comp_filename}}'

      'query:is_game album_loved:true': 'Loved Game Music/%replace_path{adjust_dap,%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'
      'query:dap_game ^franchise:^': 'Game Music/%replace_path{adjust_dap,%bucket{$franchisedir,alpha}/$franchisedir/%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'
      query:dap_game: 'Game Music/%replace_path{adjust_dap,%if{$potential_single_track,Single Tracks/$artist_title,%bucket{$game_albumdir,alpha}/$game_albumdir/$comp_filename}}'
      query:is_game: 'Game Extras/%replace_path{adjust_dap,%ifdef{franchise,$franchisedir/}%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'

      'query:dap_sole_tracks query:is_christmas': 'Christmas Music/%replace_path{adjust_dap,Single Tracks/$artist_title}'
      query:is_christmas: 'Christmas Music/%replace_path{adjust_dap,%if{$potential_single_track,$artistdir/Single Tracks/$full_title,$albumartistdir/$dap_albumdir/$comp_filename}}'

      query:dap_loved_single_tracks: 'Loved Single Tracks/%replace_path{adjust_dap,$artist_title}'
      query:dap_sole_tracks: 'Single Tracks/%replace_path{adjust_dap,$source/$artist_title}'

      'album_loved:true query:dap_soundtrack': 'Loved Soundtracks/%replace_path{adjust_dap,$dap_albumdir/$comp_filename}'
      query:dap_soundtrack: 'Soundtracks/%replace_path{adjust_dap,$dap_albumdir/$comp_filename}'

      album_loved:true: 'Loved Albums/%replace_path{adjust_dap,$dap_albumdir/$comp_filename}'
      query:dap_sampler: 'Samplers/%replace_path{adjust_dap,$dap_albumdir/$comp_filename}'

      comp:1: '%replace_path{adjust_dap,%if{$potential_single_track,Music/%bucket{$artistdir,alpha}/$artistdir/Single Tracks/$full_title,Compilations/$dap_albumdir/$comp_filename}}'
      default: '%replace_path{adjust_dap,%if{$potential_single_track,Music/%bucket{$artistdir,alpha}/$artistdir/Single Tracks/$full_title,Music/%bucket{$albumartistdir,alpha}/$albumartistdir/$dap_albumdir/$comp_filename}}'

adjust_franchise:
  'The Legend of Zelda': 'Zelda'

adjust_album:
  # Consistency
  'Video Games Live, Volume One': 'Video Games Live: Level 1'
  'Computec Edition Vol. 1': 'Computec Edition, Vol. 1'
  'Kentucky Route Zero, Act II': 'Kentucky Route Zero - Act II'
  'HGTV / Paste': 'HGTV & Paste'
  # Add missing # in the series
  'Quest for Glory: Shadows of Darkness': 'Quest for Glory IV: Shadows of Darkness'
  # Shorten album length
  'Command & Conquer∶ Red Alert': 'Red Alert'
  'Command & Conquer: Red Alert': 'Red Alert'
  'Firefly: Original Television Soundtrack': 'Firefly'
  'Forrest Gump: The Soundtrack': 'Forrest Gump'
  'Game of Thrones: Music From the HBO Series': 'Game of Thrones'
  'Gladiator: Music From the Motion Picture': 'Gladiator'
  'Indie Game: The Movie \(soundtrack\)': 'Indie Game: The Movie'
  'Moana: Original Motion Picture Soundtrack': 'Moana'
  'Mortal Kombat: Original Motion Picture Soundtrack': 'Mortal Kombat'
  'O Brother, Where Art Thou\? Music From a Film by Joel Coen & Ethan Coen': 'O Brother, Where Art Thou?'
  'Office Space: Motion Picture Soundtrack': 'Office Space'
  'The Chronicles of Riddick: Assault on Dark Athena': 'Riddick'
  'The Elder Scrolls IV: Morrowind': 'Morrowind'
  'The Elder Scrolls V: Skyrim': 'Skyrim'
  'The Incredible Adventures of Van Helsing': 'Van Helsing'
  'Quest for Glory IV: Shadows of Darkness': 'Quest for Glory IV'

adjust_artist:
  # Deal with non-alphanumeric sort issues when browsing
  ':wumpscut:': 'wumpscut'
  '\.mpegasus': 'mpegasus'
  '_ensnare_': 'ensnare'
  '“Weird Al” Yankovic': 'Weird Al Yankovic'

  # Remove featuring artists for navigation
  ' ([fF]([eE][aA])?[tT]\.|w[/／]) .*': ''

  # Multi-artist
  ' / .*': ''
  ' *[,;](?! *Jr).*': ''
  'Chris Ballew and .*': 'Chris Ballew'

  # Consistency
  'George Alistair Sanger': 'George Sanger'

  # Ease navigation
  'Amanda Palmer \+ The Grand Theft Orchestra': 'Amanda Palmer'
  'Amanda Palmer & The Grand Theft Orchestra': 'Amanda Palmer'
  'Bob Seger & the Silver Bullet Band': 'Bob Seger'
  'Ben Harper With Charlie Musselwhite': 'Ben Harper'
  'Bob Marley & The Wailers': 'Bob Marley'
  'Stafford Bawler + Todd Baker': 'Stafford Bawler'

# These replacements improve the visuals and navigation on the media player
adjust_dap:
  # Marks I don't care about
  ' *[™®©](?![a-zA-Z])': ''

  # Visual cleanup
  '[\x00-\x1f]': _
  '^\s+': ''
  '\s+$': ''

  # Revert asciify for certain chars
  '\.\.\.': '…'

  # Bad font rendering for these characters on the Shanling M0 DAP
  '“': '"'
  '”': '"'
  '‘': "'"
  '’': "'"

include:
  - config.d/smartplaylist.yaml
  - config.d/xtractor.yaml
