directory: Library
library: Library/library.db
statefile: Library/state.pickle
pluginpath:
  - ./plugins
  - ./plugins/beets-kergoth/beetsplug

per_disc_numbering: true
id3v23: true
format_album: '%ifdef{id,[$id] }$albumartist - $album%if{$albumtypes, $atypes}%aunique{}%if{$e_albumadvisory, (Explicit)}'
format_item: '%ifdef{id,[$id] }%if{$album,$album%if{$albumtypes, $atypes}%aunique{}%if{$e_albumadvisory, (Explicit)} - $disc_and_track_pre}$artist - $full_title'

sort_album: albumartist+ album+
sort_item: albumartist+ album+ disc+ track+ artist+

paths:
  default: '$source/$if_albumartist_credit/%if{$album,$album%aunique{},[non-album tracks]}/$path_filename'
  singleton: '$source/$artist/[non-album tracks]/$path_filename'
  comp: '$source/Compilations/%if{$album,$album%aunique{},[non-album tracks]}/$path_filename'
  ext:log: $albumpath/$album
  ext:cue: $albumpath/$album

# For unicode lookalikes, see:
# http://www.unicode.org/Public/security/latest/confusables.txt
replace:
  # Avoid trailing periods, invalid on Windows
  ' E\.P\.': ' EP'
  ' *(\.\.\.)$': '…'
  '\.+$': ''

  # Zero-width space
  '​': ''

  # Colon in paths is often unsupported. Use a unicode lookalike.
  ' *:': '∶'

  # Remaining default configuration for portability
  '[\\/]': _
  '^\.+': _
  '[\x00-\x1f]': _
  # '[<>"\?\*\|]': _
  '\s+$': ''
  '^\s+': ''
  '^-': _

path_sep_replace: ／

import:
  log: Library/import.log
  timid: true
  incremental: true
  default_action: skip

# Files matching these patterns are deleted from source after import
clutter:
  - '*.m3u'
  # Default:
  - Thumbs.DB
  - .DS_Store

match:
  preferred:
    countries: ['US', 'XW', 'GB|UK']
    media: ['Digital Media|File', 'CD']
  strong_rec_thresh: 0.075
  medium_rec_thresh: 0.125
  max_rec:
    unmatched_tracks: low
    missing_tracks: strong
  # The higher the weight, the lower the items go in the candidate list (greater
  # distance) when this penalty is applied.
  distance_weights:
    # Default: 3.0
    album: 6.0
    # Default: 3.0
    artist: 7.0
    # Default: 2.0
    totaltracks: 4.0
    # Default: 0.9
    missing_tracks: 1.0
    # Default: 0.6
    unmatched_tracks: 10.0
  ignored_media:
    ['DVD', 'DVD-Video', 'Blu-ray', 'HD-DVD', 'VCD', 'SVCD', 'UMD', 'VHS']

plugins:
  # Stock plugins
  - acousticbrainz
  - albumtypes
  - badfiles
  - bareasc
  - bucket
  - convert
  - chroma
  - discogs
  - duplicates
  - edit
  - embedart
  - export
  - fetchart
  - fromfilename
  - fuzzy
  - hook
  - info
  - importfeeds
  - inline
  - lastgenre
  - mbsync
  - missing
  - playlist
  - random
  - smartplaylist
  - spotify
  - the
  - types
  - unimported
  - zero

  # 3rd party plugins
  - alternatives
  - bandcamp
  - copyartifacts
  - join_albums

  # My plugins
  # Define beet command aliases, much like you can with git
  - alias
  # Write playlists to the alternatives
  - alternativesplaylist
  # Set 'advisory' and 'albumadvisory' fields on import based on 'itunesadvisory'
  - advisory
  # Define format strings for the default list formats, format_album and format_item.
  - defaultformats
  # Named queries and query prefixes from the Beets source. 'any:', @ prefix
  # for exact match, and ^ prefix for a None value.
  - existingqueries
  # Query whether an item has embedded art
  - hasart
  # Run external scripts on hook events
  - hookscripts
  # Inspect candidate changes when importing
  - importinspect
  # Identify albums whose tracks have inconsistent album fields
  - inconsistentalbumtracks
  # Keep track of the most recently imported items, useful in hooks
  - last_import
  # Modify fields in imported items
  - modifyonimport
  # Modify fields with formats/templates
  - modifytmpl
  # Expect source to be set
  - musicsource
  # - nowrite
  # % prefix for non-NULL/non-None
  - otherqueries
  # Lets you query items whose albums match a sub-query
  - crossquery
  # Prompt choice to launch picard when importing
  - picard
  # Allow certain set_fields to apply to skipped items on reimport
  - reimportskipfields
  # Add `replace` format function for applying specific sets of replacements
  - replaceformat
  # Define saved format strings by storing them in fields
  - savedformats
  # Define named/saved queries, and define fields using those queries
  - savedqueries
  # List tracks spotify identifies as explicit/parental advisory
  - spotifyexplicit
  # Clear fields in albums in the database, obeying the 'zero' plugin configuration.
  - zeroalbum

  # - autofix
  # - check
  # - describe
  # - musicintegrity
  # - xtractor
  # - yearfixer

hookscripts:
  hookspath:
    - 'hooks'
    - '../hooks'
  hooks:
    - alternatives_before_update
    - alternatives_after_update
    - import
  args:
    'alternatives_before_update': 'alternative.name, alternative.directory'
    'alternatives_after_update': 'alternative.name, alternative.directory'

acousticbrainz:
  tags:
    - bpm
    - mood_acoustic
    - mood_aggressive
    - mood_electronic
    - mood_happy
    - mood_party
    - mood_relaxed
    - mood_sad

alias:
  aliases:
    # Utilities
    # $ beet get-config alias.aliases.reimport
    get-config: '!sh -c "for arg; do beet config | yq e \".$arg\" -; done" -'
    # $ beet get-config-path library
    get-config-path: '!sh -c "p=\"$(beet config | yq e \".$1\" -)\"; cd \"${BEETSDIR:-~/.config/beets}\" && abspath \"$p\"" -'

    # Latest additions
    recent-albums: ls -a -f '$added $format_album' 'added-'
    recent: ls -f '$added $format_item' 'added-'
    last-week: ls -f '$added $format_item' 'added-' 'added:-7d..'
    last-month: ls -f '$added $format_item' 'added-' 'added:-30d..'

    # Reimport unidentified items
    reimport-mb: import -L mb_albumid:@

    # Strip release-specific tags. Useful in cases where the precise release
    # is unknown, or is not in MusicBrainz yet.
    norelease: modify 'asin!' 'isrc!' 'barcode!' 'catalognumber!' 'label!' 'media!' 'releasecountry!' 'releasestatus!' 'mb_albumid!' 'mb_workid!' 'mb_trackid!' 'mb_releasetrackid!' 'mb_releasegroupid!'

    # Extract embedded art only for albums missing a cover art file
    extract-missing-art: extractart -a artpath:^

    # Clear embedded art from albums that have an artpath
    clearart-albums: clearart album_id::. ^artpath:^

    missing-art: fetchart -q

    # Mac-specific
    reveal: open -R --
    picard: 'open -A "-a MusicBrainz\ Picard" --'
    vlc: 'open -A "-a VLC" --'

    # Complete non-game/non-christmas albums with more than one track
    non-game-albums: ls -a existing:2.. missing:0 ^query:is_game ^query:is_christmas

    # Very basic dupe check for albums lacking musicbrainz data, primarily
    simple-dupe-check: 'dup -Fa -k albumartist -k album -k disctotal -k albumtotal -f "[$id] $albumartist - $album - $existing/$albumtotal via $source"'
    dup-albums: dup -aF

    music: ls \^query:is_non_music
    singletons: ls singleton:true
    complete: ls -a incomplete:0
    high-res: albums-for samplerate:96000..

    # Show incomplete albums, skipping any albums where I only have one track
    incomplete-albums: 'ls -a -f "[$id] $albumartist - $album $existing/$albumtotal" missing:1.. \^query:is_game single_track:0'
    incomplete-games: 'ls -a -f "[$id] $albumartist - $album $existing/$albumtotal" missing:2.. single_track:0 query:is_game'

    # Red flags
    empty-artist: ls artist:@
    empty-album: ls album:@ singleton:false
    book-not-audiobook: ls genre:book ^albumtype:audiobook
    unknown-source: ls source:Unknown , source:@
    excess-tracks: 'ls -f "$format_item $track/$tracktotal via $source" excess_tracks:1'
    red-flags: '!sh -c "(set -x; beet empty-artist; beet empty-album; beet book-not-audiobook; beet unknown-source; beet excess-tracks) | python3 -c \"import sys; d=sys.stdin.read(); print(d); sys.exit(bool(d))\""'

    # Potential concerns
    missing-albumtotal: 'ls -a -f "$format_album $existing_by_disc" single_track:0 albumtotal:0'
    # This is automatically corrected in my import hook
    various-not-comp: ls -a album_query:is_various_not_comp

    # Informative
    non-mb-albums: ls -a mb_albumid:@
    possible-singles: ls -a albumtotal:1 albumtype::'^(|other)$'
    possible-not-comp: ls -a comp:1 incomplete:0 is_comp_same_artists:1
    # These are often not an issue, just albums which feature multiple
    # artists, but aren't compilations. Cases where the album artist is the
    # producer, cases where there are featuring artist, etc.
    multiartist-not-comp: ls -a comp:0 multiartist:1
    has-multiple-genres: ls -a -f '$album_genres $format_album' all_same_genres:0

alternativesplaylist:
  auto: True
  is_relative: true
  relative_to: playlist
  playlist_dir: _Playlists

bandcamp:
  art: true
  lyrics: true
  description: comments
  split_artist_title: true

bucket:
  bucket_alpha: ['A - D', 'E - L', 'M - R', 'S - Z']
  bucket_alpha_regex:
    'A - D': ^[0-9a-dA-D…äÄ]

copyartifacts:
  extensions: .cue .log .jpg .png .txt .pdf .doc .rtf

extrafiles:
  patterns:
    cue: '*.cue'
    log: '*.log'
    art:
      - '*.jpg'
      - '*.png'
    docs:
      - '*.pdf'
      - '*.txt'
      - '*.doc'
      - '*.rtf'

edit:
  itemfields: track title artist album albumdisambig tracktotal year
  albumfields: album albumartist

embedart:
  auto: false

fetchart:
  # Default
  sources: filesystem coverart itunes amazon albumart
  # Set art_source field
  store_source: true

importfeeds:
  formats: m3u_multi
  dir: Playlists/Imports

# hook:
#   hooks:
#     - event: import
#       command: 'sh -c ''[ -z "$BEETS_NO_HOOKS" ] && "${{BEETSDIR:-~/.config/beets}}/hooks/import"'''
#     # - event: alternatives_before_update
#     #   command: 'sh -c ''[ -z "$BEETS_NO_HOOKS" ] && "${{BEETSDIR:-~/.config/beets}}/hooks/alternatives_before_update"'''
#     # - event: alternatives_before_update
#     #   command: 'sh -c ''[ -z "$BEETS_NO_HOOKS" ] && "${{BEETSDIR:-~/.config/beets}}/hooks/alternatives_after_update"'''

# Also ignore @eaDir from the Synology NAS
ignore:
  - '@eaDir'
  # Default ignores:
  - .*
  - '*~'
  - System Volume Information
  - lost+found

importinspect:
  ignored:
    - day
    - month
    - original_day
    - original_month
  ignored_new:
    # When inspecting candidates, it's a given that release fields will
    # be added, and a number of these are shown already by the import interface,
    # so focus on non-release fields. Changes to existing release fields will still
    # be shown, as that's useful when retagging an existing item.
    - albumstatus
    - asin
    - barcode
    - catalognumber
    - catalognum
    - country
    - data_source
    - discogs_albumid
    - isrc
    - label
    - language
    - mb_albumartistid
    - mb_albumid
    - mb_artistid
    - mb_releasegroupid
    - mb_releasetrackid
    - mb_trackid
    - mb_workid
    - media
    - releasecountry
    - releasestatus
    - script

inconsistentalbumtracks:
  ignored_fields: added genre language r128_album_gain r128_album_peak rg_album_gain rg_album_peak

lastgenre:
  auto: false
  force: no

modifyonimport:
  modify_album:
    # Sane default for albumartist_sort
    'albumartist_sort::"^$" albumartist::"^The "': 'albumartist_sort=%the{$albumartist}'
    # Likely a single
    # 'albumtotal:1 albumtype::"^(|other)$"': 'albumtype=single albumtypes=$single_albumtypes'
    # 'Various Artists' albums not flagged as compilations
    'album_query:is_various_not_comp': 'comp=1'
    # Genre
    'genre:Holiday': 'genre=Christmas'
  modify_album_items:
    '':
      # Sane default for artist_sort
      'artist_sort::"^$" artist::"^The "': 'artist_sort=%the{$artist}'
      # Genre
      'genre:Holiday': 'genre=Christmas'
  modify_singleton:
    # Sane default for artist_sort
    'artist_sort::"^$" artist::"^The "': 'artist_sort=%the{$artist}'
    # Clear out the album field for imported singletons
    'album::.': 'album='
    # Genre
    'genre:Holiday': 'genre=Christmas'

musicbrainz:
  extra_tags: [year, catalognum, country, media, label]
  searchlimit: 10

playlist:
  auto: true
  relative_to: playlist
  playlist_dir: Library/Playlists

reimportskipfields:
  set_fields: reimported

types:
  # Default values
  e_advisory: int
  e_albumadvisory: int
  e_loved: bool

  # Built-in or Plugin fields
  albumtotal: int
  bpm: int

  # Album inline and format fields
  album_id: int
  album_loved: bool
  existing: int
  is_comp_same_artists: bool
  has_explicit_track: bool
  all_same_genres: bool
  multiartist: bool
  multidisc: bool
  single_track: bool
  potential_single_track: bool
  incomplete: bool
  average_bpm: int

  # Item inline and format fields
  excess_tracks: bool

  # Flexible fields
  #franchise: string
  #game: string
  #gamedisambig: string
  loved: bool

  ## set_fields
  reimported: bool

zero:
  fields: month day original_month original_day comments
  comments: [EAC, LAME]
  update_database: true

# It's irritating that we can't reference other inline fields to avoid this
# code duplication amongst album and item fields.
album_fields:
  album_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  # Number of existing tracks in this album
  existing: len(items)

  # Used by the missing-albumtotal alias
  existing_by_disc: |
    from itertools import groupby
    def keyfunc(i):
      return i.disc or 0
    grouped = groupby(sorted(items, key=keyfunc), keyfunc)
    by_disc = [(k, len(list(v))) for k, v in grouped]
    return ','.join(str(v[1]) for v in sorted(by_disc))

  # Not used at this time, only made available
  existing_discs: |
    discs = sorted(set(i.disc for i in items if i.disc))
    return ','.join(str(d) for d in discs)

  single_track: len(items) == 1

  multidisc: disctotal > 1
  # Let me search for albums that may be a compilation but aren't flagged
  multiartist: not bool(all(item.artist == items[0].artist for item in items))

  # Heuristic based approach to determining whether an album is incomplete. If
  # we have tracktotals, then we can take the naive approach, but if not, we
  # can assume that if the # of tracks is less than the highest track number,
  # this is an incomplete album. For example, an album with a single track
  # whose track number is 9, we can assume it's incomplete.
  #
  # This is needed as the `missing` plugin gives a negative value for any
  # album lacking tracktotal.
  incomplete: |
    from beets import config

    per_disc = config['per_disc_numbering'].get(bool)
    if per_disc:
      from itertools import groupby
      def keyfunc(i):
        return i.disc or 1
      grouped = groupby(sorted(items, key=keyfunc), keyfunc)
      by_disc = dict((k, list(v)) for k, v in grouped)
    else:
      by_disc = {1: items}

    for disc, disc_items in by_disc.items():
      tracktotal = disc_items[0].tracktotal
      if tracktotal:
        if (tracktotal - len(disc_items)) > 0:
          return True
      else:
        # Lacking tracktotals, the best we can do is make some assumptions
        # based on the track numbers. If we have a single track 9, clearly
        # tracks 1 through 8 are missing.
        tracknumbers = [item.track for item in disc_items]
        highest = max(tracknumbers)
        if highest:
          existing = len(disc_items)
          if highest != existing:
            return True
          else:
            tracknumbers.sort()
            if tracknumbers != list(range(1, highest+1)):
              return True
    return False

  # This is flagged as a compilation, but all the track artists are the same.
  # Consider setting albumartist instead. This only works when missing:0 at
  # the moment, as I can't get to the list of *available* tracks, only the
  # existing ones.
  is_comp_same_artists: comp and all(item.artist == items[0].artist for item in items)

  has_explicit_track: any(getattr(item, 'advisory', 0) == 1 for item in items)

  all_same_genres: all(item.genre == items[0].genre for item in items)

  album_all_genre: items[0].genre if all(item.genre == items[0].genre for item in items) else ''
  album_all_composer: items[0].composer if all(item.composer == items[0].composer for item in items) else ''

  album_genres: "','.join(sorted(set(item.genre for item in items)))"

  # For albums with bpm tags on all their tracks, give us the mean
  average_bpm: |
    item_bpms = [getattr(i, 'bpm', 0) for i in items]
    if all(i > 0 for i in item_bpms):
      return int(sum(item_bpms) / len(items))
    else:
      return 0

  excess_tracks: bool(albumtotal and existing > albumtotal)

item_fields:
  item_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  excess_tracks: bool(tracktotal and track and track > tracktotal)

  # disc and track prefix with ' - ' sep. Returns '' if track == 0 or this is the only track.
  disc_and_track_pre: |
    if not track or (tracktotal and tracktotal == 1):
      return ''
    elif disctotal > 1:
      return u'%02i.%02i - ' % (disc, track)
    else:
      return u'%02i - ' % track

  # Avoid the leading zero
  trim_track: str(track)
  trim_disc: str(disc)

  explicit_or_clean: |
    if 'advisory' in globals():
      if advisory == 1:
        return ' (Explicit)'
      elif advisory == 2:
        return ' (Clean)'
    else:
      return ''

  definite_year: u'%04i' % original_year or original_date[:3] or year or date[:3] or 0
  single_albumtypes: |
    if 'albumtypes' in globals():
      types = [t.strip() for t in albumtypes.split(';')]
      for t in ['other', 'album', 'ep']:
        if t in types:
          types.remove(t)
      types.insert(0, 'single')
      return '; '.join(types)
    return 'single'

album_formats:
  # Convenience
  album_id: '$id'
  album_loved: '%ifdef{loved,$loved}'

  # Used in path formats
  if_albumartist_credit: '%if{$albumartist_credit,$albumartist_credit,$albumartist}'
  comp_albumartist: '%if{$comp,Compilations,$albumartist}'
  albumsdir: '%if{$incomplete,Incomplete }Albums'
  _albumdir: '%the{%replace{adjust_album,$album%aunique{}%if{$e_albumadvisory, (Explicit)}}}'
  _albumartistdir: '%the{%asciify{%replace{adjust_artist,$comp_albumartist}}}'

  # Fallbacks from item fields
  albumdir: '$_albumdir'
  albumartistdir: '$_albumartistdir'

  # Deal with undefined values for queries
  e_albumadvisory: '%ifdef{albumadvisory,$albumadvisory,0}'
  e_data_source: '%ifdef{data_source}'

item_formats:
  # Used in path formats
  artist_title: '%the{$path_artist} - $full_title'
  albumdir: '%if{$album,$_albumdir,[non-album tracks]}'
  albumartistdir: '%if{$album,$_albumartistdir,$path_artist}'
  artistdir: '%the{$path_artist}'
  path_artist: '%asciify{%replace{adjust_artist,$artist}}'
  full_title: '$title%if{$e_advisory,$explicit_or_clean}'
  comp_filename: '%if{$album,$disc_and_track_pre}%if{$comp,$path_artist - }$full_title'
  # Unasciified, credited artist
  path_filename: '%if{$album,$disc_and_track_pre}%if{$comp,%if{$artist_credit,$artist_credit,$artist} - }$full_title'

  # Deal with undefined values for queries. This lets me do ls e_advisory:0,
  # instead of having to check for advisory:@.
  e_advisory: '%ifdef{advisory,$advisory,0}'
  e_data_source: '%ifdef{data_source}'
  e_loved: '%ifdef{loved,$loved,false}'

  # alternatives
  alt_dap: '%ifdef{alt.dap}'
  alt_testdap: '%ifdef{alt.testdap}'

  # Like albumdir, but uses Single Tracks rather than [non-album tracks]
  dap_albumdir: '%if{$album,$_albumdir,Single Tracks}'
  gamedir: '%the{%replace{adjust_album,$game%ifdef{gamedisambig, [$gamedisambig]}}}'
  game_albumdir: '%ifdef{game,$gamedir,$dap_albumdir}'

album_queries:
  # This is used both in an alias command and an import hook
  is_various_not_comp: 'comp:0 albumartist:@"Various Artists"'

item_queries:
  is_music: '^query:is_non_music'
  is_complete: 'incomplete:0'

  is_non_music: 'genre:speech , genre:meditation , genre:dharma , genre:book , genre:spoken , genre:background , albumtype:spokenword , albumtype:audiobook , albumtype:"audio drama" , albumtype:interview'
  is_christmas: 'genre:Christmas'
  is_classical: 'genre:Classical'
  is_live: 'albumtype:live'
  is_game: 'genre:game'
  is_soundtrack: 'genre:soundtrack , albumtype:soundtrack'
  is_single: 'albumtype:single'
  is_mfp: 'label:"Music for Programming"'
  is_ocremix: 'label:"OverClocked ReMix"'
  is_sampler: 'albumtype:sampler , album:sampler'

  potential_single_track: 'singleton:true , single_track:true'
  dap_maybe_single_track: 'query:is_music \^query:is_mfp \^query:is_ocremix \^query:is_sampler \^query:is_game'

  type_soundtrack: 'albumtype:soundtrack , albumtypes:soundtrack'
  dap_classical: 'genre:Classical ^loved:true ^composer:"Christopher Tin"'
  dap_game: '^game:^ , query:type_soundtrack query:is_game'
  dap_game_extra: '^query:type_soundtrack query:is_game'
  dap_loved_single_tracks: 'playlist:Loved query:potential_single_track'
  dap_single_tracks: '\^playlist:"Loved" playlist:"Single Tracks"'

alternatives:
  dap:
    directory: '../DAP'
    formats: link
    query: ^userrating:0
    paths:
      query:is_non_music: '%replace_path{dap_replace,Non-Music/$genre/$albumartistdir/$dap_albumdir/$comp_filename}'
      query:is_mfp: '%replace_path{dap_replace,Music/$label/$full_title}'
      'query:dap_single_tracks query:dap_classical': '%replace_path{dap_replace,Classical Music/Single Tracks/$artist_title}'
      query:dap_classical: '%replace_path{dap_replace,Classical Music/%if{$potential_single_track,$artistdir/Single Tracks/$full_title,$albumartistdir/$dap_albumdir/$comp_filename}}'
      'query:dap_single_tracks query:is_christmas': '%replace_path{dap_replace,Christmas Music/Single Tracks/$artist_title}'
      query:is_christmas: '%replace_path{dap_replace,Christmas Music/%if{$potential_single_track,$artistdir/Single Tracks/$full_title,$albumartistdir/$dap_albumdir/$comp_filename}}'
      'query:is_game loved:true': '%replace_path{dap_replace,Loved Game Music/%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'
      'query:dap_game potential_single_track:true': '%replace_path{dap_replace,Game Music/%ifdef{franchise,%bucket{$franchise,alpha}/$franchise/}Single Tracks/$artist_title}'
      query:dap_game: '%replace_path{dap_replace,Game Music/%ifdef{franchise,%bucket{$franchise,alpha}/$franchise/,%bucket{$game_albumdir,alpha}/}$game_albumdir/$comp_filename}'
      query:is_game: '%replace_path{dap_replace,Game Extras/%ifdef{franchise,$franchise/}%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'
      query:dap_loved_single_tracks: '%replace_path{dap_replace,Loved Single Tracks/$artist_title}'
      query:dap_single_tracks: '%replace_path{dap_replace,Single Tracks/$source/$artist_title}'
      'loved:true albumtype:soundtrack': '%replace_path{dap_replace,Loved Soundtracks/$dap_albumdir/$comp_filename}'
      query:is_soundtrack: '%replace_path{dap_replace,%if{$potential_single_track,Soundtracks/Single Tracks/$artist_title,Soundtracks/$dap_albumdir/$comp_filename}}'
      loved:true: '%replace_path{dap_replace,Loved Albums/$dap_albumdir/$comp_filename}'
      query:is_sampler: '%replace_path{dap_replace,%if{$potential_single_track,Samplers/Single Tracks/$artist_title,Samplers/$dap_albumdir/$comp_filename}}'
      comp:1: '%replace_path{dap_replace,%if{$potential_single_track,Music/%bucket{$artistdir,alpha}/$artistdir/Single Tracks/$full_title,Compilations/$dap_albumdir/$comp_filename}}'
      default: '%replace_path{dap_replace,%if{$potential_single_track,Music/%bucket{$artistdir,alpha}/$artistdir/Single Tracks/$full_title,Music/%bucket{$albumartistdir,alpha}/$albumartistdir/$dap_albumdir/$comp_filename}}'

  testdap:
    directory: '../Test'
    formats: link
    query: query:dap_game ^userrating:0
    playlists: false
    paths:
      query:is_non_music: '%replace_path{dap_replace,Non-Music/$genre/$albumartistdir/$dap_albumdir/$comp_filename}'
      query:is_mfp: '%replace_path{dap_replace,Music/$label/$full_title}'
      'query:dap_single_tracks query:is_christmas': '%replace_path{dap_replace,Christmas Music/Single Tracks/$artist_title}'
      query:is_christmas: '%replace_path{dap_replace,Christmas Music/%if{$potential_single_track,$artistdir/Single Tracks/$full_title,$albumartistdir/$dap_albumdir/$comp_filename}}'
      # query:is_ocremix: '%replace_path{dap_replace,Game Music/$label/%if{$potential_single_track,Single Tracks/$artist_title,$dap_albumdir/$comp_filename}}'
      'query:is_game loved:true': '%replace_path{dap_replace,Loved Game Music/%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'
      'query:dap_game potential_single_track:true': '%replace_path{dap_replace,Game Music/%ifdef{franchise,%bucket{$franchise,alpha}/$franchise/}Single Tracks/$artist_title}'
      query:dap_game: '%replace_path{dap_replace,Game Music/%ifdef{franchise,%bucket{$franchise,alpha}/$franchise/,%bucket{$game_albumdir,alpha}/}$game_albumdir/$comp_filename}'
      query:is_game: '%replace_path{dap_replace,Game Extras/%ifdef{franchise,$franchise/}%if{$potential_single_track,Single Tracks/$artist_title,$game_albumdir/$comp_filename}}'
      'query:dap_single_tracks query:dap_classical': '%replace_path{dap_replace,Classical Music/Single Tracks/$artist_title}'
      query:dap_classical: '%replace_path{dap_replace,Classical Music/%if{$potential_single_track,$artistdir/Single Tracks/$full_title,$albumartistdir/%replace_path{adjust_classical_album,$dap_albumdir}/$comp_filename}}'
      query:dap_loved_single_tracks: '%replace_path{dap_replace,Loved Single Tracks/$artist_title}'
      query:dap_single_tracks: '%replace_path{dap_replace,Single Tracks/$source/$artist_title}'
      'loved:true albumtype:soundtrack': '%replace_path{dap_replace,Loved Soundtracks/$dap_albumdir/$comp_filename}'
      query:is_soundtrack: '%replace_path{dap_replace,%if{$potential_single_track,Soundtracks/Single Tracks/$artist_title,Soundtracks/$dap_albumdir/$comp_filename}}'
      loved:true: '%replace_path{dap_replace,Loved Albums/$dap_albumdir/$comp_filename}'
      query:is_sampler: '%replace_path{dap_replace,%if{$potential_single_track,Samplers/Single Tracks/$artist_title,Samplers/$dap_albumdir/$comp_filename}}'
      comp:1: '%replace_path{dap_replace,%if{$potential_single_track,Music/%bucket{$artistdir,alpha}/$artistdir/Single Tracks/$full_title,Compilations/$dap_albumdir/$comp_filename}}'
      default: '%replace_path{dap_replace,%if{$potential_single_track,Music/%bucket{$artistdir,alpha}/$artistdir/Single Tracks/$full_title,Music/%bucket{$albumartistdir,alpha}/$albumartistdir/$dap_albumdir/$comp_filename}}'

adjust_album:
  # Consistency
  'Video Games Live, Volume One': 'Video Games Live: Level 1'
  'Computec Edition Vol. 1': 'Computec Edition, Vol. 1'
  'Kentucky Route Zero, Act II': 'Kentucky Route Zero - Act II'
  'HGTV / Paste': 'HGTV & Paste'
  # Shorten album length
  'The Incredible Adventures of Van Helsing': 'Van Helsing'
  'The Chronicles of Riddick: Assault on Dark Athena': 'Riddick'
  'The Elder Scrolls IV: Morrowind': 'Morrowind'
  'The Elder Scrolls V: Skyrim': 'Skyrim'
  'Command & Conquer∶ Red Alert': 'Red Alert'
  # Easier to locate by game name
  'Sogno di Volare \(Civilization VI Main Theme\)': 'Civilization VI'
  # Add missing # in the series
  'Quest for Glory: Shadows of Darkness (official soundtrack)': 'Quest for Glory IV: Shadows of Darkness'

adjust_classical_album:
  ' *[,;/／].*': ''

adjust_artist:
  # Deal with non-alphanumeric sort issues when browsing
  ':wumpscut:': 'wumpscut'
  '\.mpegasus': 'mpegasus'
  '_ensnare_': 'ensnare'
  '“Weird Al” Yankovic': 'Weird Al Yankovic'

  # Remove featuring artists for navigation
  ' ([fF]([eE][aA])?[tT]\.|w[/／]) .*': ''

  # Multi-artist
  ' / .*': ''
  ' *[,;](?! *Jr).*': ''
  'Chris Ballew and .*': 'Chris Ballew'

  # Consistency
  'George Alistair Sanger': 'George Sanger'

  # Ease navigation
  'Amanda Palmer \+ The Grand Theft Orchestra': 'Amanda Palmer'
  'Amanda Palmer & The Grand Theft Orchestra': 'Amanda Palmer'
  'Bob Seger & the Silver Bullet Band': 'Bob Seger'
  'Ben Harper With Charlie Musselwhite': 'Ben Harper'
  'Bob Marley & The Wailers': 'Bob Marley'
  'Stafford Bawler + Todd Baker': 'Stafford Bawler'

# These replacements improve the visuals and navigation on the media player
dap_replace:
  # Marks I don't care about
  ' *[™®©](?![a-zA-Z])': ''

  # Visual cleanup
  '[\x00-\x1f]': _
  '^\s+': ''
  '\s+$': ''

  # Revert asciify for certain chars
  '\.\.\.': '…'

  # Bad font rendering for these characters on the Shanling M0 DAP
  '“': '"'
  '”': '"'
  '‘': "'"
  '’': "'"

include:
  - config.d/smartplaylist.yaml
  - config.d/xtractor.yaml
