directory: ../Library
library: ../Library/library.db
# Ugh, relative plugin paths are based on PWD, not BEETSDIR
pluginpath:
  - ./plugins
  - ./Beets/plugins

per_disc_numbering: yes
id3v23: yes
format_item: '[$id] %if{$album,$album - $disc_and_track - }$artist - $title'
sort_item: albumartist+ album+ disc+ track+ artist+
format_album: '[$id] $albumartist - $album'
sort_album: albumartist+ album+
path_sep_replace: _
asciify_paths: true

import:
  log: ./import.log
  timid: yes
  incremental: yes
  # I prefer to adjust my tags manually with Picard prior to importing into
  # beets, as I can more easily manually match and search for releases.
  write: no
  autotag: no

paths:
  default: '$source/$comp_albumartist/$album%aunique{}/$disc_and_track - $title'
  'label:Music for Programming': '$source/$label/$album%aunique{}/$disc_and_track - $title'
  singleton: '$source/$artist/[non-album tracks]/$title'
  comp: '$source/$comp_albumartist/$album%aunique{}/$disc_and_track - $title'
  ext:log: $albumpath/$album
  ext:cue: $albumpath/$album

# For unicode lookalikes, see:
# http://www.unicode.org/Public/security/latest/confusables.txt
#
# This isn't ideal, as these are *not* the correct unicode characters, but it
# looks close enough visually on the media player, while being compatible with
# its filesystem, which is the goal. Ideally I'd run very very few
# replacements on my main library, and have additional ones in
# beets-alternatives for use on the digital audio player.
replace:
  ':': '∶'
  '/': '⧸'
  '\\': '⧹'
  '\|': '￨'
  '\*': '∗'

  '^[-\.]': ''
  '[-;\.]$': ''
  '[\x00-\x1f]': _
  '[<>"\?]': ''
  '\s+$': ''
  '^\s+': ''

# Defaults for fields I generally set on the import command-line
set_fields:
  source: 'Unknown'

plugins:
  - alternatives
  - badfiles
  - chroma
  - copyartifacts
  - duplicates
  - edit
  - embedart
  - fetchart
  - hook
  - importadded
  - importfeeds
  - info
  - inline
  - inline_hook
  - last_import
  - mbsync
  - missing
  - noimport
  - playlist
  - smartplaylist
  - the
  - types

copyartifacts:
  extensions: .cue .log .jpg .png .txt

hook:
  hooks:
    - event: import
      command: "sh -c '\"[ -z \"$BEETS_NO_HOOKS\" ] && ${{BEETSDIR:-~/.config/beets}}/hooks/import\" \"$@\"' - \"{lib.path}\" \"{lib.directory}\" \"{paths}\""

importadded:
  preserve_mtimes: true

importfeeds:
  formats: m3u m3u_multi
  dir: Library/Playlists/Recent
  relative_to: ..

playlist:
    auto: yes
    relative_to: ..
    playlist_dir: Library/Playlists

# It's irritating that we can't reference other inline fields to avoid this
# code duplication amongst album and item fields.
album_fields:
  album_field_context: str(globals())

  # Number of existing tracks in this album
  existing: len(items)
  single_track: 1 if len(items) == 1 else 0

  # Let me search for albums that may be a compilation but aren't flagged
  is_comp_albumartist: |
    if comp:
      return 0
    elif albumartist and not all(item.artist == albumartist for item in items):
      # This isn't always a compilation, for example in albums with featuring
      # artists on some of the tracks
      return 1
    else:
      return 0
  is_various_no_comp: |
    if comp:
      return 0
    elif albumartist == 'Various Artists':
      return 1
    else:
      return 0

  # This is flagged as a compilation, but all the track artists are the same.
  # Consider setting albumartist instead. This only works when missing:0 at
  # the moment, as I can't get to the list of *available* tracks, only the
  # existing ones.
  is_comp_same_artists: |
    if comp and all(item.artist == items[0].artist for item in items):
      return 1
    else:
      return 0

  comp_albumartist: |
    if albumartist and albumartist != 'Various Artists':
      return albumartist[1:] if albumartist.startswith('.') else albumartist
    elif comp:
      return 'Compilations'
    else:
      return albumartist[1:] if albumartist.startswith('.') else albumartist
  non_music: |
    lgenre = genre.lower()
    lalbumtype = albumtype.lower()
    if any(i in lgenre for i in ('speech', 'meditation', 'dharma', 'book', 'spoken')):
      return 1
    elif any(i in lalbumtype for i in ('spokenword', 'audiobook', 'audio drama', 'interview')):
      return 1
    else:
      return 0

item_fields:
  item_field_context: str(globals())

  disc_count: u'%02i.' % (disc)
  multiartist: 1 if albumartist != artist else 0
  multidisc: 1 if disctotal > 1 else 0
  # disc and track prefix with ' - ' sep. Returns an empty string if track == 0.
  disc_and_track_pre: |
    if disctotal > 1:
      return u'%02i.%02i - ' % (disc, track)
    elif track == 0:
      return ''
    else:
      return u'%i - ' % track
  # track prefix with ' - ' sep. Returns an empty string if track == 0.
  track_pre: |
    if track == 0:
      return ''
    else:
      return u'%i - ' % track
  disc_and_track: u'%02i.%02i' % (disc, track) if disctotal > 1 else u'%02i' % (track)
  comp_title: |
    if comp:
      return u'%s - %s' % (artist, title)
    else:
      return title

alternatives:
  dap:
    directory: ../DAP
    paths:
      default: '%if{$single_track,Single Tracks/$artist - $title,%if{$missing,Incomplete ,}Albums/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}}'

      'label:Music for Programming': '%if{$missing,Incomplete ,}Albums/$label/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'

      genre:Background: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Speech: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Meditation: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Dharma: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Book: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Spoken: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      albumtype:spokenword: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      albumtype:audiobook: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      albumtype:audio drama: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      albumtype:interview: 'Non-Music/$genre/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'

      genre:Christmas: 'Christmas Albums/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Classical: 'Classical Albums/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Game: 'Game Albums/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      singleton: 'Single Tracks/$artist - $title'
      album:sampler: 'Samplers/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      genre:Soundtrack: 'Soundtrack Albums/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      albumtype:soundtrack: 'Soundtrack Albums/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      albumtype:single: 'Singles/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'
      # I use comp_albumartist here, not Compilations, as I prefer to be under
      # the album artist if it's set to something other than Various Artists.
      comp: 'Albums/$comp_albumartist/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre$artist - $title'

    query: ''
    formats: link
    removable: true

include:
  - config/smartplaylist.yaml
