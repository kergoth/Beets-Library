directory: ../Library
library: ../Library/library.db
# Ugh, relative plugin paths are based on PWD, not BEETSDIR
pluginpath:
  - ./plugins
  - ./Beets/plugins

per_disc_numbering: yes
id3v23: yes
format_album: '[$id] $albumartist - %if{$album,$album,[non-album tracks]}'
format_item: '[$id] %if{$singleton,,$album - $disc_and_track_pre}$artist - $title'
sort_album: albumartist+ album+
sort_item: albumartist+ album+ disc+ track+ artist+
path_sep_replace: '／'
asciify_paths: true

import:
  log: ./import.log
  timid: yes
  incremental: yes

paths:
  default: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  singleton: '$source/$artist/[non-album tracks]/$title'
  comp: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  ext:log: $albumpath/$album
  ext:cue: $albumpath/$album

# For unicode lookalikes, see:
# http://www.unicode.org/Public/security/latest/confusables.txt
#
# This isn't ideal, as these are *not* the correct unicode characters, but it
# looks close enough visually on the media player, while being compatible with
# its filesystem, which is the goal. Ideally I'd run very very few
# replacements on my main library, and have additional ones in
# beets-alternatives for use on the digital audio player.
replace:
  ':': '∶'
  '/': '／'
  '\\': '⧹'
  '\|': '￨'
  '\*': '∗'


  '^[-\.]': ''
  '[-;\.]$': ''
  '[\x00-\x1f]': _
  '\s+$': ''
  '^\s+': ''

# Defaults for fields I generally set on the import command-line
set_fields:
  source: 'Unknown'

plugins:
  - alternatives
  - badfiles
  - chroma
  - copyartifacts
  - duplicates
  - edit
  - embedart
  - fetchart
  - format_fields
  - hook
  - importadded
  - importfeeds
  - info
  - inline
  - inline_hook
  - last_import
  - mbsync
  - missing
  - noimport
  - playlist
  - smartplaylist
  - the
  - types

copyartifacts:
  extensions: .cue .log .jpg .png .txt .pdf .doc .rtf

hook:
  hooks:
    - event: import
      command: "sh -c '[ -z \"$BEETS_NO_HOOKS\" ] && \"${{BEETSDIR:-~/.config/beets}}/hooks/import\" \"$@\"' - \"{lib.path}\" \"{lib.directory}\" \"{paths}\""

importadded:
  preserve_mtimes: true

importfeeds:
  formats: m3u m3u_multi
  dir: Library/Playlists/Recent
  relative_to: ..

playlist:
    auto: yes
    relative_to: ..
    playlist_dir: Library/Playlists

# It's irritating that we can't reference other inline fields to avoid this
# code duplication amongst album and item fields.
album_fields:
  album_field_context: str(globals())

  # Number of existing tracks in this album
  existing: len(items)
  single_track: 1 if len(items) == 1 else 0

  # Let me search for albums that may be a compilation but aren't flagged
  is_comp_albumartist: |
    if comp:
      return 0
    elif albumartist and not all(item.artist == albumartist for item in items):
      # This isn't always a compilation, for example in albums with featuring
      # artists on some of the tracks
      return 1
    else:
      return 0
  is_various_no_comp: |
    if comp:
      return 0
    elif albumartist == 'Various Artists':
      return 1
    else:
      return 0

  # This is flagged as a compilation, but all the track artists are the same.
  # Consider setting albumartist instead. This only works when missing:0 at
  # the moment, as I can't get to the list of *available* tracks, only the
  # existing ones.
  is_comp_same_artists: |
    if comp and all(item.artist == items[0].artist for item in items):
      return 1
    else:
      return 0

  comp_albumartist: |
    if label and label in ['Music for Programming']:
      return label
    elif albumartist and albumartist != 'Various Artists':
      return albumartist[1:] if albumartist.startswith('.') else albumartist
    elif comp:
      return 'Compilations'
    else:
      return albumartist[1:] if albumartist.startswith('.') else albumartist

  # FIXME: see if there's a function for the default query behavior, i.e.
  # 'foo:bar', rather than rolling it myself
  non_music: |
    lgenre = genre.lower()
    lalbumtype = albumtype.lower()
    if any(i in lgenre for i in ('speech', 'meditation', 'dharma', 'book', 'spoken')):
      return 1
    elif any(i in lalbumtype for i in ('spokenword', 'audiobook', 'audio drama', 'interview')):
      return 1
    else:
      return 0

item_fields:
  item_field_context: str(globals())

  multidisc: 1 if disctotal > 1 else 0
  # disc and track prefix with ' - ' sep. Returns an empty string if track == 0.
  disc_and_track_pre: |
    if not track:
      return ''
    elif disctotal > 1:
      return u'%02i.%02i - ' % (disc, track)
    else:
      return u'%02i - ' % track

  # Strip the leading zeros
  trim_track: str(track)
  trim_disc: str(disc)

format_fields:
  item_fields:
    album_directory_name: '%the{$album%aunique{}}'
    album_directory_alldiscs: '%if{$album,%the{$album%aunique{}},[non-album tracks]}'
    album_directory: '%if{$album,%the{$_album_directory},[non-album tracks]}'
    the_album_directory: '%if{$album,$_album_directory,[non-album tracks]}'
    _album_directory: '$album%aunique{}%if{$multidisc, Disc $trim_disc}%if{$disctitle,: $disctitle}'
    comp_filename: '$track_pre%if{$comp,$artist - $title,$title}'
    track_pre: '%if{$track,$trim_track - }'

the:
  # Temporary, for compatibility with old layout
  a: false

alternatives:
  dap:
    directory: ../DAP
    paths:
      genre:Background: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      genre:Speech: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      genre:Meditation: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      genre:Dharma: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      genre:Book: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      genre:Spoken: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      albumtype:spokenword: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      albumtype:audiobook: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      albumtype:audio drama: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'
      albumtype:interview: 'Non-Music/$genre/$comp_albumartist/$album_directory/$comp_filename'

      genre:Christmas: '$genre Albums/$comp_albumartist/$album_directory/$comp_filename'
      genre:Classical: '$genre Albums/$comp_albumartist/$album_directory/$comp_filename'
      genre:Game: 'Game Albums/$album_directory/$comp_filename'

      singleton: 'Single Tracks/$artist - $title'
      album:sampler: 'Samplers/$album_directory/$comp_filename'
      genre:Soundtrack: '%if{$single_track,Single Tracks/$artist - $title,Soundtrack Albums/$the_album_directory/$comp_filename}'
      albumtype:soundtrack: '%if{$single_track,Single Tracks/$artist - $title,Soundtrack Albums/$the_album_directory/$comp_filename}'
      albumtype:single: 'Singles/$comp_albumartist/$album_directory/$comp_filename'

      # I want these to be categorized as albums, not single tracks, and
      # grouped by label, not artist. I'm not a big fan of this hardcoded
      # exception, however, so I may set a field and go based on that
      # instead.
      'label:Music for Programming': '%if{$missing,Incomplete ,}Albums/$label/$album%aunique{}%if{$multidisc, Disc $disc}%if{$disctitle,: $disctitle}/$track_pre%if{$comp,$artist - $title,$title}'

      comp: '%if{$single_track,Single Tracks/$artist - $title,%if{$missing,Incomplete ,}Albums/$comp_albumartist/$album_directory/$comp_filename}'
      default: '%if{$single_track,Single Tracks/$artist - $title,%if{$missing,Incomplete ,}Albums/$comp_albumartist/$album_directory/$comp_filename}'

    query: ''
    formats: link
    removable: true

include:
  - config/smartplaylist.yaml
