directory: ../Library
library: ../Library/library.db
statefile: ../Library/state.pickle
# Ugh, relative plugin paths are based on PWD, not BEETSDIR
pluginpath:
  - ./plugins
  - ./Beets/plugins

ui:
  color: true

per_disc_numbering: true
id3v23: true
format_album: '$format_album'
format_item: '$format_item'
sort_album: albumartist+ album+
sort_item: albumartist+ album+ disc+ track+ artist+

paths:
  default: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  singleton: '$source/$artist/[non-album tracks]/$title'
  comp: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  ext:log: $albumpath/$album
  ext:cue: $albumpath/$album

# For unicode lookalikes, see:
# http://www.unicode.org/Public/security/latest/confusables.txt
#
# This isn't ideal, as these are *not* the correct unicode characters, but it
# looks close enough visually, while being compatible with the filesystem,
# which is the goal.
replace:
  ' *:': '∶'

path_sep_replace: ／

import:
  log: ../Library/import.log
  timid: true
  incremental: true
  set_fields:
    # source is where I obtained the music. iTunes, Amazon, Other, etc.
    source: 'Unknown'

match:
  preferred:
    countries: ['US', 'GB|UK']
    media: ['Digital Media|File', 'CD']
    original_year: yes
  max_rec:
    unmatched_tracks: low
  ignored_media: ['Data CD', 'DVD', 'DVD-Video', 'Blu-ray', 'HD-DVD',
                  'VCD', 'SVCD', 'UMD', 'VHS']

plugins:
  # Stock plugins
  - absubmit
  - acousticbrainz
  - badfiles
  - convert
  - chroma
  - discogs
  - duplicates
  - edit
  - embedart
  - fetchart
  - fromfilename
  - hook
  - info
  - inline
  - mbsync
  - missing
  - playlist
  - smartplaylist
  - the
  - types

  # 3rd party plugins
  - alternatives
  - bandcamp
  - copyartifacts
  - noimport

  # My plugins
  - abcalc
  - alias
  - alias_query
  - existing_queries
  - format_fields
  - inline_hook
  - last_import
  - other_queries
  - replace

  # My disabled plugins
  #
  # Add ITUNESADVISORY to mediafile. I'm using a flexible attribute 'advisory'
  # instead to avoid the issues with the mediafile extension support.
  # - itunesadvisory
  #
  # Python conditional template func. For example:
  #   %pyif{int("$something") > 0 && int("$somethingelse") < 0,foo}
  # - pyif

acousticbrainz:
  tags:
    - bpm
    - mood_acoustic
    - mood_aggressive
    - mood_electronic
    - mood_happy
    - mood_party
    - mood_relaxed
    - mood_sad

alias:
  aliases:
    # $ beet get-config alias.aliases.reimport
    get-config: '!sh -c "beet config | yq -r \".$1\"" -'
    # $ beet get-config-path library
    get-config-path: '!sh -c "p=\"$(beet config | yq -r \".$1\")\"; cd \"${BEETSDIR:-~/.config/beets}\" && abspath \"$p\"" -'

    reimport: import -maL
    reimport-mb: reimport mb_albumid::'^$'

    # Strip release-specific tags. Useful in cases where the precise release
    # is unknown, or is not in MusicBrainz yet.
    norelease: modify 'asin!' 'isrc!' 'barcode!' 'catalognumber!' 'label!' 'media!' 'releasecountry!' 'releasestatus!' 'mb_albumid!' 'mb_workid!' 'mb_trackid!' 'mb_releasetrackid!' 'mb_releasegroupid!'

    # Extract embedded art only for albums missing a cover art file
    extract-missing-art: extractart -a artpath::^$

    missing-art: fetchart -q
    reveal: open -R

    dup-albums: dup -aF
    dup-a: dup-albums

    # Complete non-game/non-christmas albums with more than one track
    non-game-albums: complete single_track:0 ^alias:is_game ^alias:is_christmas

    # Very basic dupe check for albums lacking musicbrainz data, primarily
    simple-dupe-check: 'dup -Fa -k albumartist -k album -k disctotal -k tracktotal -f "[$id] $albumartist - $album - $existing/$albumtotal via $source"'

    singletons: ls singleton:true
    complete: ls -a incomplete:0
    high-res: albums-for samplerate:96000..

    # Show incomplete albums, skipping any albums where I only have one track
    incomplete-albums: 'ls -a -f "[$id] $albumartist - $album $existing/$albumtotal" missing:1 \^alias:is_game single_track:false'
    incomplete-games: 'ls -a -f "[$id] $albumartist - $album $existing/$albumtotal" missing:2.. single_track:false alias:is_game'

    # Albums with no albumtotal/tracktotals set
    missing-albumtotal: 'ls -a -f "$format_album $existing_by_disc" single_track:0 albumtotal::"^0$"'

    # Red flags
    empty-artist: ls artist::'^$'
    empty-album: ls album::'^$' singleton:false
    book-not-audiobook: ls genre:book '^albumtype:audiobook'
    unknown-source: ls source:Unknown

    # Potential concerns
    various-not-comp: ls -a is_various_not_comp:true
    unknown-soundtracks: albums-for albumtype:soundtrack \^genre:soundtrack \^genre:game \^genre:videogame \^genre:vgm

    # Informative
    non-mb-albums: ls -a mb_albumid::^$
    possible-singles: albums-for tracktotal:1 albumtype::^$
    # These are often not an issue, just albums which feature multiple
    # artists, but aren't compilations. Cases where the album artist is the
    # producer, cases where there are featuring artist, etc.
    multiartist-not-comp: ls -a comp:false multiartist:true

    recent: ls -a 'added+' -f '$added $format_album'
    latest: recent

bandcamp:
  art: true
  split_artist_title: true

copyartifacts:
  extensions: .cue .log .jpg .png .txt .pdf .doc .rtf

fetchart:
  # Shanling M0 with 3.0 firmware supports a max of 8192x8192
  maxwidth: 8192
  # Default
  sources: filesystem coverart itunes amazon albumart
  # Set art_source field
  store_source: true

hook:
  hooks:
    - event: import
      command: "sh -c '[ -z \"$BEETS_NO_HOOKS\" ] && \"${{BEETSDIR:-~/.config/beets}}/hooks/import\" \"$@\"' - \"{lib.path}\" \"{lib.directory}\" \"{paths}\""

inline_hook:
  hooks:
    - event: import_task_created
      handler: |
        from beets import config, ui
        set_fields = config['import']['set_fields']
        if 'source' not in set_fields.keys() or set_fields['source'].as_str() == 'Unknown':
          raise ui.UserError('No source specified, please include --set=source=SOURCE')

playlist:
  auto: true
  relative_to: ..
  playlist_dir: Library/Playlists

types:
  # Manually set fields. Use e_<field> to deal with it being undefined
  # db-only version of itunesadvisory. 2 == Explicit, 1 == Clean
  advisory: int

  # Album inline and format fields
  existing: int
  is_comp_same_artists: bool
  is_various_not_comp: bool
  multiartist: bool
  multidisc: bool
  single_track: bool
  incomplete: bool
  is_incomplete: int
  first_tracktotal: int
  average_bpm: int

  # Item inline and format fields
  non_music: bool
  excess_tracks: bool

  # Existing fields to deal with lacking or wrong defaults
  e_advisory: int
  e_missing: int

# It's irritating that we can't reference other inline fields to avoid this
# code duplication amongst album and item fields.
album_fields:
  album_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  # Number of existing tracks in this album
  existing: len(items)
  existing_by_disc: |
    from itertools import groupby
    def keyfunc(i):
      return i.disc or 0
    grouped = groupby(sorted(items, key=keyfunc), keyfunc)
    by_disc = [(k, len(list(v))) for k, v in grouped]
    return ','.join(str(v[1]) for v in sorted(by_disc))

  single_track: len(items) == 1

  multidisc: 1 if disctotal > 1 else 0
  # Let me search for albums that may be a compilation but aren't flagged
  multiartist: not bool(all(item.artist == items[0].artist for item in items))

  # Heuristic based approach to determining whether an album is incomplete. If
  # we have tracktotals, then we can take the naive approach, but if not, we
  # can assume that if the # of tracks is less than the highest track number,
  # this is an incomplete album. For example, an album with a single track
  # whose track number is 9, we can assume it's incomplete.
  #
  # This is needed as the `missing` plugin gives a negative value for any
  # album lacking tracktotal.
  incomplete: |
    from beets import config

    per_disc = config['per_disc_numbering'].get(bool)
    if per_disc:
      from itertools import groupby
      def keyfunc(i):
        return i.disc or 1
      grouped = groupby(sorted(items, key=keyfunc), keyfunc)
      by_disc = dict((k, list(v)) for k, v in grouped)
    else:
      by_disc = {1: items}

    for disc, disc_items in by_disc.items():
      tracktotal = disc_items[0].tracktotal
      if tracktotal:
        if (tracktotal - len(disc_items)) > 0:
          return True
      else:
        # Lacking tracktotals, the best we can do is make some assumptions
        # based on the track numbers. If we have a single track 9, clearly
        # tracks 1 through 8 are missing.
        tracknumbers = [item.track for item in disc_items]
        highest = max(tracknumbers)
        if highest:
          existing = len(disc_items)
          if highest != existing:
            return True
          else:
            tracknumbers.sort()
            if tracknumbers != list(range(1, highest+1)):
              return True
    return False

  is_various_not_comp: |
    if comp:
      return 0
    elif albumartist == 'Various Artists':
      return 1
    else:
      return 0

  # This is flagged as a compilation, but all the track artists are the same.
  # Consider setting albumartist instead. This only works when missing:0 at
  # the moment, as I can't get to the list of *available* tracks, only the
  # existing ones.
  is_comp_same_artists: |
    if comp and all(item.artist == items[0].artist for item in items):
      return 1
    else:
      return 0

  comp_albumartist: |
    if comp:
      return 'Compilations'
    else:
      return albumartist

  explicit_or_clean_album: |
    for item in items:
      advisory = getattr(item, 'advisory', 0)
      if advisory == 1:
        return ' (Explicit)'
    return ''

  album_discs: |
    discs = sorted(set(i.disc for i in items if i.disc))
    return ','.join(str(d) for d in discs)
  first_tracktotal: items[0].tracktotal

  # For albums with bpm tags on all their tracks, give us the mean
  average_bpm: |
    item_bpms = [getattr(i, 'bpm', 0) for i in items]
    if all(i > 0 for i in item_bpms):
      return int(sum(item_bpms) / len(items))
    else:
      return 0

item_fields:
  item_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  excess_tracks: 1 if tracktotal and track and track > tracktotal else 0

  # disc and track prefix with ' - ' sep. Returns an empty string if track == 0.
  disc_and_track_pre: |
    if not track:
      return ''
    elif disctotal > 1:
      return u'%02i.%02i - ' % (disc, track)
    else:
      return u'%02i - ' % track

  # Strip the leading zero
  trim_track: str(track)
  trim_disc: str(disc)

  explicit_or_clean: |
    if 'advisory' in globals():
      if advisory == 1:
        return ' (Explicit)'
      elif advisory == 2:
        return ' (Clean)'
    else:
      return ''

  # Skip the track prefix if it's a single track of a single-track album
  alt_track_pre: |
    if not track or (tracktotal and tracktotal == 1):
      return ''
    else:
      return '%i - ' % track

  non_music: |
    lgenre = genre.lower()
    lalbumtype = albumtype.lower()
    if any(i in lgenre for i in ('speech', 'meditation', 'dharma', 'book', 'spoken')):
      return 1
    elif any(i in lalbumtype for i in ('spokenword', 'audiobook', 'audio drama', 'interview')):
      return 1
    else:
      return 0

  definite_year: u'%04i' % original_year or original_date[:3] or year or date[:3] or 0

format_fields:
  album_fields:
    format_album: '[$id] $albumartist - %if{$album,$album,[non-album tracks]}'

    # Used in path formats
    albumsdir: '%if{$incomplete,Incomplete }Albums'
    _albumdir: '%the{$album%aunique{}}$explicit_or_clean_album'
    albumartistdir: '%asciify{%first{$comp_albumartist}}'

    # Fallbacks from item fields
    albumdir: '$_albumdir'

    # Deal with undefined values for queries
    # This isn't undefined, but is negative when tracktotal/albumtotal is 0
    e_missing: '%if{$albumtotal,$missing,0}'

    is_incomplete: '%if{$first_tracktotal,%if{$missing,1,0},%if{$incomplete,1,0}}'

  item_fields:
    format_item: '[$id] %if{$singleton,,$album - $disc_and_track_pre}$artist - $title'

    # Used in path formats
    # singleton is an item field, not an album field, obviously..
    artist_title: '%first{$artist} - $full_title'
    albumdir: '%if{$singleton,[non-album tracks],$_albumdir}'
    full_title: '$title%if{$e_advisory,$explicit_or_clean}'
    comp_filename: '%if{$singleton,,$disc_and_track_pre}%if{$comp,$artist_title,$full_title}'

    # Deal with undefined values for queries. This lets me do ls e_advisory:0,
    # instead of having to check for advisory::'^$'.
    e_advisory: '%ifdef{advisory}'
    e_alt_dap: '%ifdef{alt.dap}'

alias_query:
  item_queries:
    is_christmas: 'genre:Christmas , genre:Holiday'
    is_game: 'genre:game , genre:videogame , genre:vgm'
    is_soundtrack: 'genre:soundtrack , albumtype:soundtrack'
    is_single: 'albumtype:single , tracktotal:1'
    is_mfp: 'label:"Music for Programming"'

alternatives:
  dap:
    directory: ../DAP
    formats: link
    paths:
      non_music:true     : '%replace{dap_replace,Non-Music/$genre/$albumartistdir/$albumdir/$comp_filename}'
      alias:is_mfp       : '%replace{dap_replace,Albums/$label/$label/$full_title}'
      alias:is_christmas : '%replace{dap_replace,Christmas Music/$albumartistdir/$albumdir/$comp_filename}'
      alias:is_game      : '%replace{dap_replace,Game Music/$albumdir/$comp_filename}'
      singleton          : '%replace{dap_replace,Single Tracks/$artist_title}'
      album:sampler      : '%replace{dap_replace,%if{$single_track,Single Tracks/$artist_title,Samplers/$albumdir/$comp_filename}}'
      alias:is_single    : '%replace{dap_replace,Singles/$albumartistdir/$albumdir/$comp_filename}'
      alias:is_soundtrack: '%replace{dap_replace,%if{$single_track,Single Tracks/$artist_title,Soundtracks/$albumdir/$comp_filename}}'
      default            : '%replace{dap_replace,%if{$single_track,Single Tracks/$artist_title,$albumsdir/$albumartistdir/$albumdir/$comp_filename}}'

# These replacements improve the visuals and navigation on the media player
dap_replace:
  # Marks I don't care about
  ' *™': ''
  ' *\(tm\)': ''
  ' *®': ''
  ' *\(r\)': ''
  ' *©': ''
  ' *\(c\)': ''

  # Visual cleanup
  '^[-\.]': ''
  '/[-\.]': '/'
  '[-\.;]/': '/'
  '[\x00-\x1f]': _
  '^\s+': ''
  '\s+$': ''

  # Revert asciify for certain chars
  '\.\.\.': '…'

  # Bad font rendering for these characters on the Shanling M0 DAP
  '“': '"'
  '”': '"'
  '‘': "'"
  '’': "'"

include:
  - config.d/smartplaylist.yaml

#  vim: set et sts=2 sw=2 :
