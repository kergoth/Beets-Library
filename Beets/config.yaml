directory: ../Library
library: ../Library/library.db
# Ugh, relative plugin paths are based on PWD, not BEETSDIR
pluginpath:
  - ./plugins
  - ./Beets/plugins

ui:
  color: true

per_disc_numbering: true
id3v23: true
format_album: '$format_album'
format_item: '$format_item'
sort_album: albumartist+ album+
sort_item: albumartist+ album+ disc+ track+ artist+
path_sep_replace: ／

paths:
  default: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  singleton: '$source/$artist/[non-album tracks]/$title'
  comp: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  ext:log: $albumpath/$album
  ext:cue: $albumpath/$album

# For unicode lookalikes, see:
# http://www.unicode.org/Public/security/latest/confusables.txt
#
# This isn't ideal, as these are *not* the correct unicode characters, but it
# looks close enough visually on the media player, while being compatible with
# its filesystem, which is the goal. Ideally I'd run very very few
# replacements on my main library, and have additional ones in
# beets-alternatives for use on the digital audio player.
replace:
  # Unicode lookalikes
  ' *:': '∶'

  # Die, marks I don't care about
  ' *™': ''
  ' *\(tm\)': ''
  ' *®': ''
  ' *\(r\)': ''
  ' *©': ''
  ' *\(c\)': ''

  # Visual cleanup
  '^[-\.]': ''
  '/[-\.]': '/'
  '[-\.;]/': '/'
  '[\x00-\x1f]': _
  '^\s+': ''
  '\s+$': ''

  # Revert asciify for certain chars
  '\.\.\.': '…'

import:
  log: ./import.log
  timid: true
  incremental: true
  set_fields:
    # source is where I obtained the music. iTunes, Amazon, Other, etc.
    source: 'Unknown'

plugins:
  # Stock plugins
  - badfiles
  - chroma
  - duplicates
  - edit
  - embedart
  - fetchart
  - hook
  - info
  - inline
  - mbsync
  - missing
  - playlist
  - smartplaylist
  - the
  - types

  # 3rd party plugins
  - alternatives
  - copyartifacts
  - noimport

  # My plugins
  - alias
  - alias_query
  - format_fields
  - last_import

  # My disabled plugins
  # - inline_hook
  # - itunesadvisory

alias:
  aliases:
    reimport: import -maL
    reimport-mb: reimport mb_albumid::'^$'
    dup-albums: dup -aF
    dup-a: dup-albums
    singletons: ls singleton:true

    # Strip release-specific tags. Useful in cases where the precise release
    # is unknown, or is not in MusicBrainz yet.
    norelease: modify 'asin!' 'isrc!' 'barcode!' 'catalognumber!' 'label!' 'media!' 'releasecountry!' 'releasestatus!' 'mb_albumid!' 'mb_workid!' 'mb_trackid!' 'mb_releasetrackid!' 'mb_releasegroupid!'

    # get-config library; get-config alias.aliases.reimport
    get-config: '!sh -c "beet config | yq -r \".$1\"" -'

    # Show incomplete albums, skipping any albums where I only have one track
    incomplete-albums: 'ls -a -f "[$id] $albumartist - $album, $existing/$albumtotal, missing $missing tracks" missing:2.. single_track:false , missing:1 \\^genre:game \\^genre:videogame \\^genre:vgm single_track:false'

    # Very basic dupe check for albums lacking musicbrainz data, primarily
    simple-dupe-check: 'dup -Fa -k albumartist -k album -k disctotal -k tracktotal -f "[$id] $albumartist - $album - $existing/$albumtotal via $source"'

    # Red flags
    empty-artist: ls artist::'^$'
    empty-album: ls album::'^$' singleton:false
    book-not-audiobook: ls genre:book '^albumtype:audiobook'
    unknown-source: source:Unknown

    # Potential concerns
    various-not-comp: ls -a is_various_not_comp:true
    unknown-soundtracks: albums-for albumtype:soundtrack \^genre:soundtrack \^genre:game \^genre:videogame \^genre:vgm

    # Informative
    non-mb-albums: ls -a mb_albumid::^$
    possible-singles: albums-for tracktotal:1 albumtype::^$
    # These are often not an issue, just albums which feature multiple
    # artists, but aren't compilations. Cases where the album artist is the
    # producer, cases where there are featuring artist, etc.
    multiartist-not-comp: ls -a comp:false multiartist:true


copyartifacts:
  extensions: .cue .log .jpg .png .txt .pdf .doc .rtf

hook:
  hooks:
    - event: import
      command: "sh -c '[ -z \"$BEETS_NO_HOOKS\" ] && \"${{BEETSDIR:-~/.config/beets}}/hooks/import\" \"$@\"' - \"{lib.path}\" \"{lib.directory}\" \"{paths}\""

playlist:
  auto: true
  relative_to: ..
  playlist_dir: Library/Playlists

types:
  # Manually set fields. Use e_<field> to deal with it being undefined
  # db-only version of itunesadvisory. 2 == Explicit, 1 == Clean
  advisory: int

  # Album inline and format fields
  existing: int
  is_comp_same_artists: bool
  is_various_not_comp: bool
  multiartist: bool
  multidisc: bool
  single_track: bool
  incomplete: bool
  is_incomplete: bool

  # Item inline and format fields
  non_music: bool
  excess_tracks: bool

  # Existing fields to deal with lacking or wrong defaults
  e_advisory: int
  e_missing: int

# It's irritating that we can't reference other inline fields to avoid this
# code duplication amongst album and item fields.
album_fields:
  album_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  # Number of existing tracks in this album
  existing: len(items)
  existing_by_disc: |
    from itertools import groupby
    def keyfunc(i):
      return i.disc or 0
    grouped = groupby(sorted(items, key=keyfunc), keyfunc)
    by_disc = [(k, len(list(v))) for k, v in grouped]
    return ','.join(str(v[1]) for v in sorted(by_disc))

  single_track: len(items) == 1

  multidisc: 1 if disctotal > 1 else 0
  # Let me search for albums that may be a compilation but aren't flagged
  multiartist: not bool(all(item.artist == items[0].artist for item in items))

  # Heuristic based approach to determining whether an album is incomplete. If
  # we have tracktotals, then we can take the naive approach, but if not, we
  # can assume that if the # of tracks is less than the highest track number,
  # this is an incomplete album. For example, an album with a single track
  # whose track number is 9, we can assume it's incomplete.
  #
  # This is needed as the `missing` plugin gives a negative value for any
  # album lacking tracktotal.
  is_incomplete: |
    from beets import config

    per_disc = config['per_disc_numbering'].get(bool)
    if per_disc:
      from itertools import groupby
      def keyfunc(i):
        return i.disc or 0
      grouped = groupby(sorted(items, key=keyfunc), keyfunc)
      by_disc = dict((k, list(v)) for k, v in grouped)
    else:
      by_disc = {1: items}

    for disc, disc_items in by_disc.items():
      tracktotal = disc_items[0].tracktotal
      if tracktotal:
        if (tracktotal - len(disc_items)) > 0:
          return True
      else:
        # We can't know how many tracks are missing without tracktotal,
        # but we can at least assume tracks are missing if we only have
        # a single track #9 and nothing else, for example.
        highest = max(item.track for item in disc_items)
        if highest:
          # Only use this approach if we have track numbers
          existing = len(disc_items)
          if (highest - existing) > 0:
            return True
    return False

  is_various_not_comp: |
    if comp:
      return 0
    elif albumartist == 'Various Artists':
      return 1
    else:
      return 0

  # This is flagged as a compilation, but all the track artists are the same.
  # Consider setting albumartist instead. This only works when missing:0 at
  # the moment, as I can't get to the list of *available* tracks, only the
  # existing ones.
  is_comp_same_artists: |
    if comp and all(item.artist == items[0].artist for item in items):
      return 1
    else:
      return 0

  comp_albumartist: |
    if comp:
      return 'Compilations'
    else:
      return albumartist

  explicit_or_clean_album: |
    for item in items:
      advisory = getattr(item, 'advisory', 0)
      if advisory == 1:
        return ' (Explicit)'
    return ''

  album_discs: |
    discs = sorted(set(i.disc for i in items if i.disc))
    return ','.join(str(d) for d in discs)

item_fields:
  item_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  excess_tracks: 1 if tracktotal and track and track > tracktotal else 0

  # disc and track prefix with ' - ' sep. Returns an empty string if track == 0.
  disc_and_track_pre: |
    if not track:
      return ''
    elif disctotal > 1:
      return u'%02i.%02i - ' % (disc, track)
    else:
      return u'%02i - ' % track

  # Strip the leading zero
  trim_track: str(track)
  trim_disc: str(disc)

  explicit_or_clean: |
    if 'advisory' in globals():
      if advisory == 1:
        return ' (Explicit)'
      elif advisory == 2:
        return ' (Clean)'
    else:
      return ''

  # Skip the track prefix if it's a single track of a single-track album
  alt_track_pre: |
    if not track or (tracktotal and tracktotal == 1):
      return ''
    else:
      return '%i - ' % track

  non_music: |
    lgenre = genre.lower()
    lalbumtype = albumtype.lower()
    if any(i in lgenre for i in ('speech', 'meditation', 'dharma', 'book', 'spoken')):
      return 1
    elif any(i in lalbumtype for i in ('spokenword', 'audiobook', 'audio drama', 'interview')):
      return 1
    else:
      return 0

  definite_year: u'%04i' % original_year or original_date[:3] or year or date[:3] or 0

format_fields:
  album_fields:
    format_album: '[$id] $albumartist - %if{$album,$album,[non-album tracks]}'

    # Use missing if it's not negative, otherwise use the alternate approach
    incomplete: '%if{$albumtotal,%if{$missing,1,0},$is_incomplete}'

    # Used in path formats
    albumsdir: '%if{$incomplete,Incomplete }Albums'
    _albumdir: '%the{$album%aunique{}}$explicit_or_clean_album'
    albumartistdir: '%asciify{%first{$comp_albumartist}}'

    # Fallbacks from item fields
    albumdir: '$_albumdir'

    # Deal with undefined values for queries
    # This isn't undefined, but is negative when tracktotal/albumtotal is 0
    e_missing: '%if{$albumtotal,$missing,0}'

  item_fields:
    format_item: '[$id] %if{$singleton,,$album - $disc_and_track_pre}$artist - $title'

    # Used in path formats
    # singleton is an item field, not an album field, obviously..
    artist_title: '%first{$artist} - $full_title'
    albumdir: '%if{$singleton,[non-album tracks],$_albumdir}'
    full_title: '$title%if{$e_advisory,$explicit_or_clean}'
    comp_filename: '%if{$singleton,,$disc_and_track_pre}%if{$comp,$artist_title,$full_title}'

    # Deal with undefined values for queries. This lets me do ls e_advisory:0,
    # instead of having to check for advisory::'^$'.
    e_advisory: '%ifdef{advisory}'
    e_alt_dap: '%ifdef{alt.dap}'

alias_query:
  item_queries:
    is_christmas: 'genre:Christmas , genre:Holiday'
    is_game: 'genre:game , genre:videogame , genre:vgm'
    is_soundtrack: 'genre:soundtrack , albumtype:soundtrack'
    is_single: 'albumtype:single , tracktotal:1'
    is_mfp: 'label:"Music for Programming"'

alternatives:
  dap:
    directory: ../DAP
    formats: link
    paths:
      non_music:true     : 'Non-Music/$genre/$albumartistdir/$albumdir/$comp_filename'
      alias:is_mfp       : 'Albums/$label/$label/$full_title'
      alias:is_christmas : 'Christmas Music/$albumartistdir/$albumdir/$comp_filename'
      alias:is_game      : 'Game Music/$albumdir/$comp_filename'
      singleton          : 'Single Tracks/$artist_title'
      album:sampler      : '%if{$single_track,Single Tracks/$artist_title,Samplers/$albumdir/$comp_filename}'
      alias:is_single    : 'Singles/$albumartistdir/$albumdir/$comp_filename'
      alias:is_soundtrack: '%if{$single_track,Single Tracks/$artist_title,Soundtracks/$albumdir/$comp_filename}'
      default            : '%if{$single_track,Single Tracks/$artist_title,$albumsdir/$albumartistdir/$albumdir/$comp_filename}'
    replace:
      # Bad font rendering for these characters on the Shanling M0 DAP
      '“': '"'
      '”': '"'
      '‘': "'"
      '’': "'"

include:
  - config.d/smartplaylist.yaml

#  vim: set et sts=2 sw=2 :
