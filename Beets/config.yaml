directory: ../Library
library: ../Library/library.db
# Ugh, relative plugin paths are based on PWD, not BEETSDIR
pluginpath:
  - ./plugins
  - ./Beets/plugins

per_disc_numbering: yes
id3v23: yes
format_album: '[$id] $albumartist - %if{$album,$album,[non-album tracks]}'
format_item: '[$id] %if{$singleton,,$album - $disc_and_track_pre}$artist - $title'
sort_album: albumartist+ album+
sort_item: albumartist+ album+ disc+ track+ artist+
path_sep_replace: ／

paths:
  default: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  singleton: '$source/$artist/[non-album tracks]/$title'
  comp: '$source/$comp_albumartist/%if{$album,$album%aunique{},[non-album tracks]}/$disc_and_track_pre$title'
  ext:log: $albumpath/$album
  ext:cue: $albumpath/$album

# For unicode lookalikes, see:
# http://www.unicode.org/Public/security/latest/confusables.txt
#
# This isn't ideal, as these are *not* the correct unicode characters, but it
# looks close enough visually on the media player, while being compatible with
# its filesystem, which is the goal. Ideally I'd run very very few
# replacements on my main library, and have additional ones in
# beets-alternatives for use on the digital audio player.
replace:
  # Unicode lookalikes
  ' *:': '∶'

  # Die, marks I don't care about
  ' *™': ''
  ' *\(tm\)': ''
  ' *®': ''
  ' *\(r\)': ''
  ' *©': ''
  ' *\(c\)': ''

  # Visual cleanup
  '^[-\.]': ''
  '/[-\.]': '/'
  '[-\.]/': '/'
  '[\x00-\x1f]': _
  '^\s+': ''
  '\s+$': ''

  # Revert asciify for certain chars
  '\.\.\.': '…'

import:
  log: ./import.log
  timid: yes
  incremental: yes
  set_fields:
    # source is where I obtained the music. iTunes, Amazon, Other, etc.
    source: 'Unknown'

plugins:
  # Stock plugins
  - badfiles
  - chroma
  - duplicates
  - edit
  - embedart
  - fetchart
  - hook
  - importadded
  - importfeeds
  - info
  - inline
  - mbsync
  - missing
  - playlist
  - smartplaylist
  - the
  - types

  # 3rd party plugins
  - alternatives
  # - check
  - copyartifacts
  - noimport

  # My plugins
  - format_fields
  - inline_hook
  - itunesadvisory
  - last_import

copyartifacts:
  extensions: .cue .log .jpg .png .txt .pdf .doc .rtf

hook:
  hooks:
    - event: import
      command: "sh -c '[ -z \"$BEETS_NO_HOOKS\" ] && \"${{BEETSDIR:-~/.config/beets}}/hooks/import\" \"$@\"' - \"{lib.path}\" \"{lib.directory}\" \"{paths}\""

importadded:
  preserve_mtimes: true

importfeeds:
  formats: m3u m3u_multi
  dir: Library/Playlists/Recent
  relative_to: ..

playlist:
    auto: yes
    relative_to: ..
    playlist_dir: Library/Playlists

types:
  existing: int
  is_comp_albumartist: bool
  is_comp_same_artists: bool
  is_various_no_comp: bool
  multiartist: bool
  multidisc: bool
  non_music: bool
  single_track: bool

# It's irritating that we can't reference other inline fields to avoid this
# code duplication amongst album and item fields.
album_fields:
  album_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  # Number of existing tracks in this album
  existing: len(items)
  single_track: 1 if len(items) == 1 else 0

  # Let me search for albums that may be a compilation but aren't flagged
  multiartist: 1 if not all(item.artist == items[0].artist for item in items) else 0

  is_comp_albumartist: |
    if comp:
      return 0
    elif not all(item.artist == albumartist for item in items):
      # This isn't always a compilation, for example in albums with featuring
      # artists on some of the tracks
      return 1
    else:
      return 0
  is_various_no_comp: |
    if comp:
      return 0
    elif albumartist == 'Various Artists':
      return 1
    else:
      return 0

  # This is flagged as a compilation, but all the track artists are the same.
  # Consider setting albumartist instead. This only works when missing:0 at
  # the moment, as I can't get to the list of *available* tracks, only the
  # existing ones.
  is_comp_same_artists: |
    if comp and all(item.artist == items[0].artist for item in items):
      return 1
    else:
      return 0

  comp_albumartist: |
    if albumartist and albumartist != 'Various Artists':
      return albumartist
    elif comp:
      return 'Compilations'
    else:
      return albumartist

  explicit_or_clean_album: |
    for item in items:
      advisory = getattr(item, 'itunesadvisory', '0')
      if str(advisory) == '1':
        return ' (Explicit)'
    return ''

item_fields:
  item_field_context: "', '.join(g for g in sorted(globals()) if not g.startswith('__'))"

  # alternatives
  alt_dap: globals().get('alt.dap')

  multidisc: 1 if disctotal > 1 else 0
  # disc and track prefix with ' - ' sep. Returns an empty string if track == 0.
  disc_and_track_pre: |
    if not track:
      return ''
    elif disctotal > 1:
      return u'%02i.%02i - ' % (disc, track)
    else:
      return u'%02i - ' % track

  # Strip the leading zero
  trim_track: str(track)
  trim_disc: str(disc)

  explicit_or_clean: |
    if 'itunesadvisory' in globals():
      if str(itunesadvisory) == '1':
        return ' (Explicit)'
      elif str(itunesadvisory) == '2':
        return ' (Clean)'
    return ''

  # Skip the track prefix if it's a single track of a single-track album
  alt_track_pre: |
    if not track or (tracktotal and tracktotal == 1):
      return ''
    else:
      return '%i - ' % track

  # FIXME: see if there's a function for the default query behavior, i.e.
  # 'foo:bar', rather than rolling it myself
  non_music: |
    lgenre = genre.lower()
    lalbumtype = albumtype.lower()
    if any(i in lgenre for i in ('speech', 'meditation', 'dharma', 'book', 'spoken')):
      return 1
    elif any(i in lalbumtype for i in ('spokenword', 'audiobook', 'audio drama', 'interview')):
      return 1
    else:
      return 0

format_fields:
  album_fields:
    incomplete: '%if{$tracktotal,%if{$missing,1,0},0}'
  item_fields:
    full_title: '$title%ifdef{itunesadvisory,$explicit_or_clean}'
    comp_filename_splitdiscs: '%if{$singleton,,$alt_track_pre}%if{$comp,$artist - $full_title,$full_title}'
    comp_filename_alldiscs: '%if{$singleton,,$disc_and_track_pre}%if{$comp,$artist - $full_title,$full_title}'
    comp_filename: '$comp_filename_alldiscs'
    track_pre: '%if{$track,$trim_track - }'

    albumsdir: '%if{$tracktotal,%if{$missing,Incomplete ,}}Albums'
    album_directory_alldiscs: '%if{$album,%the{$album%aunique{}}$explicit_or_clean_album,[non-album tracks]}'
    album_directory_splitdiscs: '%if{$album,%the{$_album_directory},[non-album tracks]}'
    album_directory: '$album_directory_alldiscs'
    the_album_directory: '%if{$album,$_album_directory,[non-album tracks]}'
    _album_directory: '$album%aunique{}%if{$multidisc, Disc $trim_disc}%if{$disctitle,: $disctitle}$explicit_or_clean_album'

    albumartistdir: '%asciify{%first{$comp_albumartist}}'

alternatives:
  dap:
    directory: ../DAP
    paths:
      genre:Background: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      genre:Speech: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      genre:Meditation: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      genre:Dharma: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      genre:Book: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      genre:Spoken: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      albumtype:spokenword: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      albumtype:audiobook: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      albumtype:audio drama: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'
      albumtype:interview: 'Non-Music/$genre/$albumartistdir/$album_directory/$comp_filename'

      # Flatten the various single-track `Music for Programming` albums
      'label:Music for Programming': 'Albums/$label/$label/$title'

      genre:Christmas: 'Christmas Music/$albumartistdir/$album_directory/$comp_filename'
      genre:Holiday: 'Christmas Music/$albumartistdir/$album_directory/$comp_filename'

      # Games are currently not grouped by artist, as they're like
      # a Soundtrack, and their identity is more associated with the
      # game/movie, not the composer. That said, I *do* often want to listen
      # to game music from a certain composer, so I may either change this
      # layout or create artist playlists for all the game composers.
      genre:game: 'Game Music/$album_directory/$comp_filename'
      genre:videogame: 'Game Music/$album_directory/$comp_filename'
      genre:vgm: 'Game Music/$album_directory/$comp_filename'

      singleton: 'Single Tracks/$artist - $title'
      album:sampler: '%if{$single_track,Single Tracks/$artist - $title,Samplers/$album_directory/$comp_filename}'

      albumtype:single: 'Singles/$albumartistdir/$album_directory/$comp_filename'
      tracktotal:1: 'Singles/$albumartistdir/$album_directory/$comp_filename'

      genre:Soundtrack: '%if{$single_track,Single Tracks/$artist - $title,Soundtracks/$album_directory/$comp_filename}'
      albumtype:soundtrack: '%if{$single_track,Single Tracks/$artist - $title,Soundtracks/$album_directory/$comp_filename}'

      comp: '%if{$single_track,Single Tracks/$artist - $title,$albumsdir/$albumartistdir/$album_directory/$comp_filename}'
      default: '%if{$single_track,Single Tracks/$artist - $title,$albumsdir/$albumartistdir/$album_directory/$comp_filename}'

      # Kill single tracks logic to test performance.
      # Time was 25 mins or so with stock paths, 55 minutes with these paths
      # with single tracks, now testing these paths without single tracks
      #
      # It's possible performance may improve when I can leverage album fields
      # in the query rather than only in the format
      #
      # Update: ditching the %if{} for single tracks reduces overall alt
      # update time from 55 minutes to 47 minutes. I expect the biggest issue
      # is we have to access and use album information for a given track, for
      # every track, and it determines the path on a per-track basis, so it's
      # likely having to do certain db queries repeatedly unless it caches
      # well behind the scenes. Hopefully the fix to allow album fields in
      # path queries will also speed this up, since the branch at least
      # implements some level of caching.

    query: ''
    formats: link
    removable: true

    replace:
      # Bad font rendering for these characters on the Shanling M0 DAP
      '“': '"'
      '”': '"'
      '‘': "'"
      '’': "'"

include:
  - config.d/smartplaylist.yaml

#  vim: set et sts=2 sw=2 :
